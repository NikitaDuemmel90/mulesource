/*
 * generated by Xtext 2.19.0
 */
package de.ubt.ai1.mule.serializer;

import com.google.inject.Inject;
import de.ubt.ai1.mule.muLE.AdditiveExpression;
import de.ubt.ai1.mule.muLE.AndExpression;
import de.ubt.ai1.mule.muLE.AssignmentOrOperationCall;
import de.ubt.ai1.mule.muLE.Attribute;
import de.ubt.ai1.mule.muLE.BasicType;
import de.ubt.ai1.mule.muLE.Block;
import de.ubt.ai1.mule.muLE.BooleanConstant;
import de.ubt.ai1.mule.muLE.ComparisonExpression;
import de.ubt.ai1.mule.muLE.CompilationUnit;
import de.ubt.ai1.mule.muLE.Composition;
import de.ubt.ai1.mule.muLE.DeclaredType;
import de.ubt.ai1.mule.muLE.Dereference;
import de.ubt.ai1.mule.muLE.ElseIf;
import de.ubt.ai1.mule.muLE.ElseLet;
import de.ubt.ai1.mule.muLE.Enumeration;
import de.ubt.ai1.mule.muLE.EnumerationValue;
import de.ubt.ai1.mule.muLE.EqualityExpression;
import de.ubt.ai1.mule.muLE.ExitStatement;
import de.ubt.ai1.mule.muLE.ExponentExpression;
import de.ubt.ai1.mule.muLE.IfStatement;
import de.ubt.ai1.mule.muLE.Import;
import de.ubt.ai1.mule.muLE.IntegerConstant;
import de.ubt.ai1.mule.muLE.LambdaExpression;
import de.ubt.ai1.mule.muLE.LetStatement;
import de.ubt.ai1.mule.muLE.ListAccess;
import de.ubt.ai1.mule.muLE.ListInit;
import de.ubt.ai1.mule.muLE.ListInitElements;
import de.ubt.ai1.mule.muLE.ListInitFunction;
import de.ubt.ai1.mule.muLE.ListType;
import de.ubt.ai1.mule.muLE.LoopStatement;
import de.ubt.ai1.mule.muLE.MainProcedure;
import de.ubt.ai1.mule.muLE.MuLEPackage;
import de.ubt.ai1.mule.muLE.MultiplicativeExpression;
import de.ubt.ai1.mule.muLE.Null;
import de.ubt.ai1.mule.muLE.Operation;
import de.ubt.ai1.mule.muLE.OperationInvocation;
import de.ubt.ai1.mule.muLE.OperationType;
import de.ubt.ai1.mule.muLE.OrExpression;
import de.ubt.ai1.mule.muLE.ParenthesizedExpression;
import de.ubt.ai1.mule.muLE.RationalConstant;
import de.ubt.ai1.mule.muLE.Reference;
import de.ubt.ai1.mule.muLE.ReferenceType;
import de.ubt.ai1.mule.muLE.ReturnStatement;
import de.ubt.ai1.mule.muLE.StringConstant;
import de.ubt.ai1.mule.muLE.SuperExpression;
import de.ubt.ai1.mule.muLE.SymbolRefCompositionAttribute;
import de.ubt.ai1.mule.muLE.SymbolRefCompositionInit;
import de.ubt.ai1.mule.muLE.SymbolReference;
import de.ubt.ai1.mule.muLE.TypeParameter;
import de.ubt.ai1.mule.muLE.Unary;
import de.ubt.ai1.mule.muLE.VariableDeclaration;
import de.ubt.ai1.mule.services.MuLEGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class MuLESemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MuLEGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MuLEPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MuLEPackage.ADDITIVE_EXPRESSION:
				sequence_AdditiveExpression(context, (AdditiveExpression) semanticObject); 
				return; 
			case MuLEPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case MuLEPackage.ASSIGNMENT_OR_OPERATION_CALL:
				sequence_AssignmentOrOperationCall(context, (AssignmentOrOperationCall) semanticObject); 
				return; 
			case MuLEPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case MuLEPackage.BASIC_TYPE:
				sequence_BasicType(context, (BasicType) semanticObject); 
				return; 
			case MuLEPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case MuLEPackage.BOOLEAN_CONSTANT:
				sequence_AtomicExpression(context, (BooleanConstant) semanticObject); 
				return; 
			case MuLEPackage.COMPARISON_EXPRESSION:
				sequence_ComparisonExpression(context, (ComparisonExpression) semanticObject); 
				return; 
			case MuLEPackage.COMPILATION_UNIT:
				sequence_CompilationUnit(context, (CompilationUnit) semanticObject); 
				return; 
			case MuLEPackage.COMPOSITION:
				sequence_Composition(context, (Composition) semanticObject); 
				return; 
			case MuLEPackage.DECLARED_TYPE:
				sequence_DeclaredType(context, (DeclaredType) semanticObject); 
				return; 
			case MuLEPackage.DEREFERENCE:
				sequence_SymbolRefAccessModifier(context, (Dereference) semanticObject); 
				return; 
			case MuLEPackage.ELSE_IF:
				sequence_ElseIf(context, (ElseIf) semanticObject); 
				return; 
			case MuLEPackage.ELSE_LET:
				sequence_ElseLet(context, (ElseLet) semanticObject); 
				return; 
			case MuLEPackage.ENUMERATION:
				sequence_Enumeration(context, (Enumeration) semanticObject); 
				return; 
			case MuLEPackage.ENUMERATION_VALUE:
				sequence_EnumerationValue(context, (EnumerationValue) semanticObject); 
				return; 
			case MuLEPackage.EQUALITY_EXPRESSION:
				sequence_EqualityExpression(context, (EqualityExpression) semanticObject); 
				return; 
			case MuLEPackage.EXIT_STATEMENT:
				sequence_ExitStatement(context, (ExitStatement) semanticObject); 
				return; 
			case MuLEPackage.EXPONENT_EXPRESSION:
				sequence_ExponentExpression(context, (ExponentExpression) semanticObject); 
				return; 
			case MuLEPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case MuLEPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case MuLEPackage.INTEGER_CONSTANT:
				sequence_AtomicExpression(context, (IntegerConstant) semanticObject); 
				return; 
			case MuLEPackage.LAMBDA_EXPRESSION:
				sequence_LambdaExpression(context, (LambdaExpression) semanticObject); 
				return; 
			case MuLEPackage.LET_STATEMENT:
				sequence_LetStatement(context, (LetStatement) semanticObject); 
				return; 
			case MuLEPackage.LIST_ACCESS:
				sequence_SymbolRefAccessModifier(context, (ListAccess) semanticObject); 
				return; 
			case MuLEPackage.LIST_INIT:
				sequence_ListInit(context, (ListInit) semanticObject); 
				return; 
			case MuLEPackage.LIST_INIT_ELEMENTS:
				sequence_ListInitElements(context, (ListInitElements) semanticObject); 
				return; 
			case MuLEPackage.LIST_INIT_FUNCTION:
				sequence_ListInitFunction(context, (ListInitFunction) semanticObject); 
				return; 
			case MuLEPackage.LIST_TYPE:
				sequence_ListType(context, (ListType) semanticObject); 
				return; 
			case MuLEPackage.LOOP_STATEMENT:
				sequence_LoopStatement(context, (LoopStatement) semanticObject); 
				return; 
			case MuLEPackage.MAIN_PROCEDURE:
				sequence_MainProcedure(context, (MainProcedure) semanticObject); 
				return; 
			case MuLEPackage.MULTIPLICATIVE_EXPRESSION:
				sequence_MultiplicativeExpression(context, (MultiplicativeExpression) semanticObject); 
				return; 
			case MuLEPackage.NULL:
				sequence_AtomicExpression(context, (Null) semanticObject); 
				return; 
			case MuLEPackage.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case MuLEPackage.OPERATION_INVOCATION:
				sequence_SymbolRefAccessModifier(context, (OperationInvocation) semanticObject); 
				return; 
			case MuLEPackage.OPERATION_TYPE:
				sequence_OperationType(context, (OperationType) semanticObject); 
				return; 
			case MuLEPackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case MuLEPackage.PARAMETER:
				sequence_Parameter(context, (de.ubt.ai1.mule.muLE.Parameter) semanticObject); 
				return; 
			case MuLEPackage.PARENTHESIZED_EXPRESSION:
				sequence_AtomicExpression(context, (ParenthesizedExpression) semanticObject); 
				return; 
			case MuLEPackage.RATIONAL_CONSTANT:
				sequence_AtomicExpression(context, (RationalConstant) semanticObject); 
				return; 
			case MuLEPackage.REFERENCE:
				sequence_AtomicExpression(context, (Reference) semanticObject); 
				return; 
			case MuLEPackage.REFERENCE_TYPE:
				sequence_ReferenceType(context, (ReferenceType) semanticObject); 
				return; 
			case MuLEPackage.RETURN_STATEMENT:
				sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
				return; 
			case MuLEPackage.STRING_CONSTANT:
				sequence_AtomicExpression(context, (StringConstant) semanticObject); 
				return; 
			case MuLEPackage.SUPER_EXPRESSION:
				sequence_SuperExpression(context, (SuperExpression) semanticObject); 
				return; 
			case MuLEPackage.SYMBOL_REF_COMPOSITION_ATTRIBUTE:
				sequence_SymbolRefCompositionAttribute(context, (SymbolRefCompositionAttribute) semanticObject); 
				return; 
			case MuLEPackage.SYMBOL_REF_COMPOSITION_INIT:
				sequence_SymbolRefCompositionInit(context, (SymbolRefCompositionInit) semanticObject); 
				return; 
			case MuLEPackage.SYMBOL_REFERENCE:
				sequence_SymbolReference(context, (SymbolReference) semanticObject); 
				return; 
			case MuLEPackage.TYPE_PARAMETER:
				sequence_TypeParameter(context, (TypeParameter) semanticObject); 
				return; 
			case MuLEPackage.UNARY:
				sequence_AtomicExpression(context, (Unary) semanticObject); 
				return; 
			case MuLEPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns AdditiveExpression
	 *     OrExpression returns AdditiveExpression
	 *     OrExpression.OrExpression_1_0 returns AdditiveExpression
	 *     AndExpression returns AdditiveExpression
	 *     AndExpression.AndExpression_1_0 returns AdditiveExpression
	 *     EqualityExpression returns AdditiveExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns AdditiveExpression
	 *     ComparisonExpression returns AdditiveExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns AdditiveExpression
	 *     AdditiveExpression returns AdditiveExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns AdditiveExpression
	 *
	 * Constraint:
	 *     (left=AdditiveExpression_AdditiveExpression_1_0 (op='+' | op='-' | op='&') right=MultiplicativeExpression)
	 */
	protected void sequence_AdditiveExpression(ISerializationContext context, AdditiveExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns AndExpression
	 *     OrExpression returns AndExpression
	 *     OrExpression.OrExpression_1_0 returns AndExpression
	 *     AndExpression returns AndExpression
	 *     AndExpression.AndExpression_1_0 returns AndExpression
	 *
	 * Constraint:
	 *     (left=AndExpression_AndExpression_1_0 op='and' right=EqualityExpression)
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.AND_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.AND_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.AND_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.AND_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.AND_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.AND_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndExpressionAccess().getOpAndKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getAndExpressionAccess().getRightEqualityExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns AssignmentOrOperationCall
	 *     AssignmentOrOperationCall returns AssignmentOrOperationCall
	 *
	 * Constraint:
	 *     (left=AssignmentOrOperationCall_AssignmentOrOperationCall_1_0 right=Expression)
	 */
	protected void sequence_AssignmentOrOperationCall(ISerializationContext context, AssignmentOrOperationCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.ASSIGNMENT_OR_OPERATION_CALL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.ASSIGNMENT_OR_OPERATION_CALL__LEFT));
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.ASSIGNMENT_OR_OPERATION_CALL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.ASSIGNMENT_OR_OPERATION_CALL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentOrOperationCallAccess().getAssignmentOrOperationCallLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAssignmentOrOperationCallAccess().getRightExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BooleanConstant
	 *     OrExpression returns BooleanConstant
	 *     OrExpression.OrExpression_1_0 returns BooleanConstant
	 *     AndExpression returns BooleanConstant
	 *     AndExpression.AndExpression_1_0 returns BooleanConstant
	 *     EqualityExpression returns BooleanConstant
	 *     EqualityExpression.EqualityExpression_1_0 returns BooleanConstant
	 *     ComparisonExpression returns BooleanConstant
	 *     ComparisonExpression.ComparisonExpression_1_0 returns BooleanConstant
	 *     AdditiveExpression returns BooleanConstant
	 *     AdditiveExpression.AdditiveExpression_1_0 returns BooleanConstant
	 *     MultiplicativeExpression returns BooleanConstant
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns BooleanConstant
	 *     ExponentExpression returns BooleanConstant
	 *     ExponentExpression.ExponentExpression_1_0 returns BooleanConstant
	 *     AtomicExpression returns BooleanConstant
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, BooleanConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntegerConstant
	 *     OrExpression returns IntegerConstant
	 *     OrExpression.OrExpression_1_0 returns IntegerConstant
	 *     AndExpression returns IntegerConstant
	 *     AndExpression.AndExpression_1_0 returns IntegerConstant
	 *     EqualityExpression returns IntegerConstant
	 *     EqualityExpression.EqualityExpression_1_0 returns IntegerConstant
	 *     ComparisonExpression returns IntegerConstant
	 *     ComparisonExpression.ComparisonExpression_1_0 returns IntegerConstant
	 *     AdditiveExpression returns IntegerConstant
	 *     AdditiveExpression.AdditiveExpression_1_0 returns IntegerConstant
	 *     MultiplicativeExpression returns IntegerConstant
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns IntegerConstant
	 *     ExponentExpression returns IntegerConstant
	 *     ExponentExpression.ExponentExpression_1_0 returns IntegerConstant
	 *     AtomicExpression returns IntegerConstant
	 *
	 * Constraint:
	 *     value=INTEGER
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, IntegerConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.INTEGER_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.INTEGER_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueINTEGERTerminalRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Null
	 *     OrExpression returns Null
	 *     OrExpression.OrExpression_1_0 returns Null
	 *     AndExpression returns Null
	 *     AndExpression.AndExpression_1_0 returns Null
	 *     EqualityExpression returns Null
	 *     EqualityExpression.EqualityExpression_1_0 returns Null
	 *     ComparisonExpression returns Null
	 *     ComparisonExpression.ComparisonExpression_1_0 returns Null
	 *     AdditiveExpression returns Null
	 *     AdditiveExpression.AdditiveExpression_1_0 returns Null
	 *     MultiplicativeExpression returns Null
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns Null
	 *     ExponentExpression returns Null
	 *     ExponentExpression.ExponentExpression_1_0 returns Null
	 *     AtomicExpression returns Null
	 *
	 * Constraint:
	 *     {Null}
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, Null semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ParenthesizedExpression
	 *     OrExpression returns ParenthesizedExpression
	 *     OrExpression.OrExpression_1_0 returns ParenthesizedExpression
	 *     AndExpression returns ParenthesizedExpression
	 *     AndExpression.AndExpression_1_0 returns ParenthesizedExpression
	 *     EqualityExpression returns ParenthesizedExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns ParenthesizedExpression
	 *     ComparisonExpression returns ParenthesizedExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns ParenthesizedExpression
	 *     AdditiveExpression returns ParenthesizedExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns ParenthesizedExpression
	 *     MultiplicativeExpression returns ParenthesizedExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns ParenthesizedExpression
	 *     ExponentExpression returns ParenthesizedExpression
	 *     ExponentExpression.ExponentExpression_1_0 returns ParenthesizedExpression
	 *     AtomicExpression returns ParenthesizedExpression
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, ParenthesizedExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.PARENTHESIZED_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.PARENTHESIZED_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getExpressionExpressionParserRuleCall_9_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns RationalConstant
	 *     OrExpression returns RationalConstant
	 *     OrExpression.OrExpression_1_0 returns RationalConstant
	 *     AndExpression returns RationalConstant
	 *     AndExpression.AndExpression_1_0 returns RationalConstant
	 *     EqualityExpression returns RationalConstant
	 *     EqualityExpression.EqualityExpression_1_0 returns RationalConstant
	 *     ComparisonExpression returns RationalConstant
	 *     ComparisonExpression.ComparisonExpression_1_0 returns RationalConstant
	 *     AdditiveExpression returns RationalConstant
	 *     AdditiveExpression.AdditiveExpression_1_0 returns RationalConstant
	 *     MultiplicativeExpression returns RationalConstant
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns RationalConstant
	 *     ExponentExpression returns RationalConstant
	 *     ExponentExpression.ExponentExpression_1_0 returns RationalConstant
	 *     AtomicExpression returns RationalConstant
	 *
	 * Constraint:
	 *     value=RATIONAL
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, RationalConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.RATIONAL_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.RATIONAL_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueRATIONALTerminalRuleCall_4_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Reference
	 *     OrExpression returns Reference
	 *     OrExpression.OrExpression_1_0 returns Reference
	 *     AndExpression returns Reference
	 *     AndExpression.AndExpression_1_0 returns Reference
	 *     EqualityExpression returns Reference
	 *     EqualityExpression.EqualityExpression_1_0 returns Reference
	 *     ComparisonExpression returns Reference
	 *     ComparisonExpression.ComparisonExpression_1_0 returns Reference
	 *     AdditiveExpression returns Reference
	 *     AdditiveExpression.AdditiveExpression_1_0 returns Reference
	 *     MultiplicativeExpression returns Reference
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns Reference
	 *     ExponentExpression returns Reference
	 *     ExponentExpression.ExponentExpression_1_0 returns Reference
	 *     AtomicExpression returns Reference
	 *
	 * Constraint:
	 *     expression=AtomicExpression
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, Reference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.REFERENCE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.REFERENCE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getExpressionAtomicExpressionParserRuleCall_8_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringConstant
	 *     OrExpression returns StringConstant
	 *     OrExpression.OrExpression_1_0 returns StringConstant
	 *     AndExpression returns StringConstant
	 *     AndExpression.AndExpression_1_0 returns StringConstant
	 *     EqualityExpression returns StringConstant
	 *     EqualityExpression.EqualityExpression_1_0 returns StringConstant
	 *     ComparisonExpression returns StringConstant
	 *     ComparisonExpression.ComparisonExpression_1_0 returns StringConstant
	 *     AdditiveExpression returns StringConstant
	 *     AdditiveExpression.AdditiveExpression_1_0 returns StringConstant
	 *     MultiplicativeExpression returns StringConstant
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns StringConstant
	 *     ExponentExpression returns StringConstant
	 *     ExponentExpression.ExponentExpression_1_0 returns StringConstant
	 *     AtomicExpression returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getValueSTRINGTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Unary
	 *     OrExpression returns Unary
	 *     OrExpression.OrExpression_1_0 returns Unary
	 *     AndExpression returns Unary
	 *     AndExpression.AndExpression_1_0 returns Unary
	 *     EqualityExpression returns Unary
	 *     EqualityExpression.EqualityExpression_1_0 returns Unary
	 *     ComparisonExpression returns Unary
	 *     ComparisonExpression.ComparisonExpression_1_0 returns Unary
	 *     AdditiveExpression returns Unary
	 *     AdditiveExpression.AdditiveExpression_1_0 returns Unary
	 *     MultiplicativeExpression returns Unary
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns Unary
	 *     ExponentExpression returns Unary
	 *     ExponentExpression.ExponentExpression_1_0 returns Unary
	 *     AtomicExpression returns Unary
	 *
	 * Constraint:
	 *     ((op='+' | op='-' | op='not') expression=AtomicExpression)
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, Unary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns Attribute
	 *     Feature returns Attribute
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (visibility=VisibilityModifier? name=ID type=DataType)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns BasicType
	 *     BasicType returns BasicType
	 *
	 * Constraint:
	 *     (typeName='integer' | typeName='rational' | typeName='string' | typeName='boolean')
	 */
	protected void sequence_BasicType(ISerializationContext context, BasicType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Block returns Block
	 *
	 * Constraint:
	 *     statements+=Statement*
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ComparisonExpression
	 *     OrExpression returns ComparisonExpression
	 *     OrExpression.OrExpression_1_0 returns ComparisonExpression
	 *     AndExpression returns ComparisonExpression
	 *     AndExpression.AndExpression_1_0 returns ComparisonExpression
	 *     EqualityExpression returns ComparisonExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns ComparisonExpression
	 *     ComparisonExpression returns ComparisonExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns ComparisonExpression
	 *
	 * Constraint:
	 *     (left=ComparisonExpression_ComparisonExpression_1_0 (op='<' | op='<=' | op='>' | op='>=') right=AdditiveExpression)
	 */
	protected void sequence_ComparisonExpression(ISerializationContext context, ComparisonExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompilationUnit returns CompilationUnit
	 *     NamedElement returns CompilationUnit
	 *
	 * Constraint:
	 *     ((isProgram?='program' | isLibrary?='library') name=ID imports+=Import* programElements+=ProgramElement* main=MainProcedure?)
	 */
	protected void sequence_CompilationUnit(ISerializationContext context, CompilationUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProgramElement returns Composition
	 *     NamedElement returns Composition
	 *     TypeDeclaration returns Composition
	 *     Composition returns Composition
	 *
	 * Constraint:
	 *     (
	 *         visibility=VisibilityModifier? 
	 *         abstract?='abstract'? 
	 *         name=ID 
	 *         (typeParams+=TypeParameter typeParams+=TypeParameter*)? 
	 *         (superType=[Composition|QualifiedName] (superTypeParams+=TypeParameter superTypeParams+=TypeParameter*)?)? 
	 *         typeDeclarations+=TypeDeclaration* 
	 *         attributes+=Attribute* 
	 *         operations+=Operation*
	 *     )
	 */
	protected void sequence_Composition(ISerializationContext context, Composition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns DeclaredType
	 *     DeclaredType returns DeclaredType
	 *
	 * Constraint:
	 *     (type=[TypeDeclaration|QualifiedName] (typeParams+=DataType typeParams+=DataType*)?)
	 */
	protected void sequence_DeclaredType(ISerializationContext context, DeclaredType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElseIf returns ElseIf
	 *
	 * Constraint:
	 *     (expression=Expression block=Block)
	 */
	protected void sequence_ElseIf(ISerializationContext context, ElseIf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.ELSE_IF__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.ELSE_IF__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.ELSE_IF__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.ELSE_IF__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElseIfAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getElseIfAccess().getBlockBlockParserRuleCall_3_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ElseLet returns ElseLet
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration expression=Expression block=Block)
	 */
	protected void sequence_ElseLet(ISerializationContext context, ElseLet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.ELSE_LET__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.ELSE_LET__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.ELSE_LET__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.ELSE_LET__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.ELSE_LET__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.ELSE_LET__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElseLetAccess().getVariableVariableDeclarationParserRuleCall_1_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getElseLetAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getElseLetAccess().getBlockBlockParserRuleCall_5_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns EnumerationValue
	 *     EnumerationValue returns EnumerationValue
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_EnumerationValue(ISerializationContext context, EnumerationValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumerationValueAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProgramElement returns Enumeration
	 *     NamedElement returns Enumeration
	 *     TypeDeclaration returns Enumeration
	 *     Enumeration returns Enumeration
	 *
	 * Constraint:
	 *     (visibility=VisibilityModifier? name=ID values+=EnumerationValue values+=EnumerationValue*)
	 */
	protected void sequence_Enumeration(ISerializationContext context, Enumeration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns EqualityExpression
	 *     OrExpression returns EqualityExpression
	 *     OrExpression.OrExpression_1_0 returns EqualityExpression
	 *     AndExpression returns EqualityExpression
	 *     AndExpression.AndExpression_1_0 returns EqualityExpression
	 *     EqualityExpression returns EqualityExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns EqualityExpression
	 *
	 * Constraint:
	 *     (left=EqualityExpression_EqualityExpression_1_0 (op='=' | op='/=') right=ComparisonExpression)
	 */
	protected void sequence_EqualityExpression(ISerializationContext context, EqualityExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ExitStatement
	 *     ExitStatement returns ExitStatement
	 *
	 * Constraint:
	 *     {ExitStatement}
	 */
	protected void sequence_ExitStatement(ISerializationContext context, ExitStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ExponentExpression
	 *     OrExpression returns ExponentExpression
	 *     OrExpression.OrExpression_1_0 returns ExponentExpression
	 *     AndExpression returns ExponentExpression
	 *     AndExpression.AndExpression_1_0 returns ExponentExpression
	 *     EqualityExpression returns ExponentExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns ExponentExpression
	 *     ComparisonExpression returns ExponentExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns ExponentExpression
	 *     AdditiveExpression returns ExponentExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns ExponentExpression
	 *     MultiplicativeExpression returns ExponentExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns ExponentExpression
	 *     ExponentExpression returns ExponentExpression
	 *     ExponentExpression.ExponentExpression_1_0 returns ExponentExpression
	 *
	 * Constraint:
	 *     (left=ExponentExpression_ExponentExpression_1_0 op='exp' right=AtomicExpression)
	 */
	protected void sequence_ExponentExpression(ISerializationContext context, ExponentExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.EXPONENT_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.EXPONENT_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.EXPONENT_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.EXPONENT_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.EXPONENT_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.EXPONENT_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExponentExpressionAccess().getExponentExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExponentExpressionAccess().getOpExpKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getExponentExpressionAccess().getRightAtomicExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (expression=Expression block=Block elseIfs+=ElseIf* elseBlock=Block?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=[CompilationUnit|ID]
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceCompilationUnitIDTerminalRuleCall_1_0_1(), semanticObject.eGet(MuLEPackage.Literals.IMPORT__IMPORTED_NAMESPACE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LambdaExpression
	 *     OrExpression returns LambdaExpression
	 *     OrExpression.OrExpression_1_0 returns LambdaExpression
	 *     AndExpression returns LambdaExpression
	 *     AndExpression.AndExpression_1_0 returns LambdaExpression
	 *     EqualityExpression returns LambdaExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns LambdaExpression
	 *     ComparisonExpression returns LambdaExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns LambdaExpression
	 *     AdditiveExpression returns LambdaExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns LambdaExpression
	 *     MultiplicativeExpression returns LambdaExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns LambdaExpression
	 *     ExponentExpression returns LambdaExpression
	 *     ExponentExpression.ExponentExpression_1_0 returns LambdaExpression
	 *     AtomicExpression returns LambdaExpression
	 *     LambdaExpression returns LambdaExpression
	 *
	 * Constraint:
	 *     ((parameters+=Parameter parameters+=Parameter*)? type=DataType? block=Block)
	 */
	protected void sequence_LambdaExpression(ISerializationContext context, LambdaExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LetStatement
	 *     LetStatement returns LetStatement
	 *
	 * Constraint:
	 *     (variable=VariableDeclaration expression=Expression block=Block elseLets+=ElseLet* elseBlock=Block?)
	 */
	protected void sequence_LetStatement(ISerializationContext context, LetStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ListInitElements returns ListInitElements
	 *
	 * Constraint:
	 *     elements+=Expression*
	 */
	protected void sequence_ListInitElements(ISerializationContext context, ListInitElements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ListInitFunction returns ListInitFunction
	 *
	 * Constraint:
	 *     ((op='**' | op='..') expression=Expression)
	 */
	protected void sequence_ListInitFunction(ISerializationContext context, ListInitFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ListInit
	 *     OrExpression returns ListInit
	 *     OrExpression.OrExpression_1_0 returns ListInit
	 *     AndExpression returns ListInit
	 *     AndExpression.AndExpression_1_0 returns ListInit
	 *     EqualityExpression returns ListInit
	 *     EqualityExpression.EqualityExpression_1_0 returns ListInit
	 *     ComparisonExpression returns ListInit
	 *     ComparisonExpression.ComparisonExpression_1_0 returns ListInit
	 *     AdditiveExpression returns ListInit
	 *     AdditiveExpression.AdditiveExpression_1_0 returns ListInit
	 *     MultiplicativeExpression returns ListInit
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns ListInit
	 *     ExponentExpression returns ListInit
	 *     ExponentExpression.ExponentExpression_1_0 returns ListInit
	 *     AtomicExpression returns ListInit
	 *     ListInit returns ListInit
	 *
	 * Constraint:
	 *     (left=Expression (right=ListInitFunction | right=ListInitElements))?
	 */
	protected void sequence_ListInit(ISerializationContext context, ListInit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns ListType
	 *     ListType returns ListType
	 *
	 * Constraint:
	 *     type=DataType
	 */
	protected void sequence_ListType(ISerializationContext context, ListType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.LIST_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.LIST_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getListTypeAccess().getTypeDataTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LoopStatement
	 *     LoopStatement returns LoopStatement
	 *
	 * Constraint:
	 *     block=Block
	 */
	protected void sequence_LoopStatement(ISerializationContext context, LoopStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.LOOP_STATEMENT__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.LOOP_STATEMENT__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoopStatementAccess().getBlockBlockParserRuleCall_2_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MainProcedure returns MainProcedure
	 *
	 * Constraint:
	 *     block=Block
	 */
	protected void sequence_MainProcedure(ISerializationContext context, MainProcedure semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.MAIN_PROCEDURE__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.MAIN_PROCEDURE__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMainProcedureAccess().getBlockBlockParserRuleCall_2_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MultiplicativeExpression
	 *     OrExpression returns MultiplicativeExpression
	 *     OrExpression.OrExpression_1_0 returns MultiplicativeExpression
	 *     AndExpression returns MultiplicativeExpression
	 *     AndExpression.AndExpression_1_0 returns MultiplicativeExpression
	 *     EqualityExpression returns MultiplicativeExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns MultiplicativeExpression
	 *     ComparisonExpression returns MultiplicativeExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns MultiplicativeExpression
	 *     AdditiveExpression returns MultiplicativeExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns MultiplicativeExpression
	 *     MultiplicativeExpression returns MultiplicativeExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns MultiplicativeExpression
	 *
	 * Constraint:
	 *     (left=MultiplicativeExpression_MultiplicativeExpression_1_0 (op='*' | op='/' | op='div' | op='mod') right=ExponentExpression)
	 */
	protected void sequence_MultiplicativeExpression(ISerializationContext context, MultiplicativeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns OperationType
	 *     OperationType returns OperationType
	 *
	 * Constraint:
	 *     ((paramTypes+=DataType paramTypes+=DataType*)? type=DataType?)
	 */
	protected void sequence_OperationType(ISerializationContext context, OperationType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProgramElement returns Operation
	 *     NamedElement returns Operation
	 *     Feature returns Operation
	 *     Operation returns Operation
	 *
	 * Constraint:
	 *     (
	 *         override?='override'? 
	 *         visibility=VisibilityModifier? 
	 *         abstract?='abstract'? 
	 *         name=ID 
	 *         (params+=Parameter params+=Parameter*)? 
	 *         type=DataType? 
	 *         block=Block?
	 *     )
	 */
	protected void sequence_Operation(ISerializationContext context, Operation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns OrExpression
	 *     OrExpression returns OrExpression
	 *     OrExpression.OrExpression_1_0 returns OrExpression
	 *
	 * Constraint:
	 *     (left=OrExpression_OrExpression_1_0 op='or' right=AndExpression)
	 */
	protected void sequence_OrExpression(ISerializationContext context, OrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.OR_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.OR_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrExpressionAccess().getOpOrKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getOrExpressionAccess().getRightAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns Parameter
	 *     Feature returns Parameter
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (name=ID type=DataType)
	 */
	protected void sequence_Parameter(ISerializationContext context, de.ubt.ai1.mule.muLE.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.FEATURE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.FEATURE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParameterAccess().getTypeDataTypeParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns ReferenceType
	 *     ReferenceType returns ReferenceType
	 *
	 * Constraint:
	 *     type=DataType
	 */
	protected void sequence_ReferenceType(ISerializationContext context, ReferenceType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.REFERENCE_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.REFERENCE_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReferenceTypeAccess().getTypeDataTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ReturnStatement
	 *     ReturnStatement returns ReturnStatement
	 *
	 * Constraint:
	 *     expression=Expression?
	 */
	protected void sequence_ReturnStatement(ISerializationContext context, ReturnStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SuperExpression
	 *     AssignmentOrOperationCall returns SuperExpression
	 *     AssignmentOrOperationCall.AssignmentOrOperationCall_1_0 returns SuperExpression
	 *     Expression returns SuperExpression
	 *     OrExpression returns SuperExpression
	 *     OrExpression.OrExpression_1_0 returns SuperExpression
	 *     AndExpression returns SuperExpression
	 *     AndExpression.AndExpression_1_0 returns SuperExpression
	 *     EqualityExpression returns SuperExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns SuperExpression
	 *     ComparisonExpression returns SuperExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns SuperExpression
	 *     AdditiveExpression returns SuperExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns SuperExpression
	 *     MultiplicativeExpression returns SuperExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns SuperExpression
	 *     ExponentExpression returns SuperExpression
	 *     ExponentExpression.ExponentExpression_1_0 returns SuperExpression
	 *     AtomicExpression returns SuperExpression
	 *     SuperExpression returns SuperExpression
	 *
	 * Constraint:
	 *     memberCall=SymbolReference
	 */
	protected void sequence_SuperExpression(ISerializationContext context, SuperExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.SUPER_EXPRESSION__MEMBER_CALL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.SUPER_EXPRESSION__MEMBER_CALL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSuperExpressionAccess().getMemberCallSymbolReferenceParserRuleCall_3_0(), semanticObject.getMemberCall());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SymbolRefAccessModifier returns Dereference
	 *
	 * Constraint:
	 *     accessModifier=SymbolRefAccessModifier?
	 */
	protected void sequence_SymbolRefAccessModifier(ISerializationContext context, Dereference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SymbolRefAccessModifier returns ListAccess
	 *
	 * Constraint:
	 *     (index=Expression accessModifier=SymbolRefAccessModifier?)
	 */
	protected void sequence_SymbolRefAccessModifier(ISerializationContext context, ListAccess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SymbolRefAccessModifier returns OperationInvocation
	 *
	 * Constraint:
	 *     ((params+=Expression params+=Expression*)? accessModifier=SymbolRefAccessModifier?)
	 */
	protected void sequence_SymbolRefAccessModifier(ISerializationContext context, OperationInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SymbolRefCompositionAttribute returns SymbolRefCompositionAttribute
	 *
	 * Constraint:
	 *     (attribute=[Attribute|ID] expression=Expression)
	 */
	protected void sequence_SymbolRefCompositionAttribute(ISerializationContext context, SymbolRefCompositionAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.SYMBOL_REF_COMPOSITION_ATTRIBUTE__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.SYMBOL_REF_COMPOSITION_ATTRIBUTE__ATTRIBUTE));
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.SYMBOL_REF_COMPOSITION_ATTRIBUTE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.SYMBOL_REF_COMPOSITION_ATTRIBUTE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSymbolRefCompositionAttributeAccess().getAttributeAttributeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MuLEPackage.Literals.SYMBOL_REF_COMPOSITION_ATTRIBUTE__ATTRIBUTE, false));
		feeder.accept(grammarAccess.getSymbolRefCompositionAttributeAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SymbolRefCompositionInit returns SymbolRefCompositionInit
	 *
	 * Constraint:
	 *     (attributes+=SymbolRefCompositionAttribute attributes+=SymbolRefCompositionAttribute*)?
	 */
	protected void sequence_SymbolRefCompositionInit(ISerializationContext context, SymbolRefCompositionInit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SymbolReference
	 *     AssignmentOrOperationCall returns SymbolReference
	 *     AssignmentOrOperationCall.AssignmentOrOperationCall_1_0 returns SymbolReference
	 *     Expression returns SymbolReference
	 *     OrExpression returns SymbolReference
	 *     OrExpression.OrExpression_1_0 returns SymbolReference
	 *     AndExpression returns SymbolReference
	 *     AndExpression.AndExpression_1_0 returns SymbolReference
	 *     EqualityExpression returns SymbolReference
	 *     EqualityExpression.EqualityExpression_1_0 returns SymbolReference
	 *     ComparisonExpression returns SymbolReference
	 *     ComparisonExpression.ComparisonExpression_1_0 returns SymbolReference
	 *     AdditiveExpression returns SymbolReference
	 *     AdditiveExpression.AdditiveExpression_1_0 returns SymbolReference
	 *     MultiplicativeExpression returns SymbolReference
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns SymbolReference
	 *     ExponentExpression returns SymbolReference
	 *     ExponentExpression.ExponentExpression_1_0 returns SymbolReference
	 *     AtomicExpression returns SymbolReference
	 *     SymbolReference returns SymbolReference
	 *
	 * Constraint:
	 *     (symbol=[NamedElement|ID] compositionInit=SymbolRefCompositionInit? accessModifier=SymbolRefAccessModifier? memberCall=SymbolReference?)
	 */
	protected void sequence_SymbolReference(ISerializationContext context, SymbolReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProgramElement returns TypeParameter
	 *     NamedElement returns TypeParameter
	 *     TypeDeclaration returns TypeParameter
	 *     TypeParameter returns TypeParameter
	 *
	 * Constraint:
	 *     (name=ID superType=[Composition|QualifiedName]?)
	 */
	protected void sequence_TypeParameter(ISerializationContext context, TypeParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns VariableDeclaration
	 *     Feature returns VariableDeclaration
	 *     Statement returns VariableDeclaration
	 *     VariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     (name=ID type=DataType)
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, MuLEPackage.Literals.FEATURE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MuLEPackage.Literals.FEATURE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getTypeDataTypeParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
}

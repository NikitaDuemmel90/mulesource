/*
 * generated by Xtext 2.16.0
 */
package de.ubt.ai1.mule.scoping

import com.google.inject.Inject
import de.ubt.ai1.mule.muLE.Block
import de.ubt.ai1.mule.muLE.CompilationUnit
import de.ubt.ai1.mule.muLE.Composition
import de.ubt.ai1.mule.muLE.DeclaredType
import de.ubt.ai1.mule.muLE.ElseIf
import de.ubt.ai1.mule.muLE.ElseLet
import de.ubt.ai1.mule.muLE.Enumeration
import de.ubt.ai1.mule.muLE.Expression
import de.ubt.ai1.mule.muLE.Feature
import de.ubt.ai1.mule.muLE.LambdaExpression
import de.ubt.ai1.mule.muLE.LetStatement
import de.ubt.ai1.mule.muLE.ListAccess
import de.ubt.ai1.mule.muLE.MuLEPackage
import de.ubt.ai1.mule.muLE.NamedElement
import de.ubt.ai1.mule.muLE.Operation
import de.ubt.ai1.mule.muLE.OperationInvocation
import de.ubt.ai1.mule.muLE.Statement
import de.ubt.ai1.mule.muLE.SymbolReference
import de.ubt.ai1.mule.muLE.TypeParameter
import de.ubt.ai1.mule.muLE.VariableDeclaration
import de.ubt.ai1.mule.typing.MuLETypeProvider
import java.util.ArrayList
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.SimpleScope

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class MuLEScopeProvider extends AbstractMuLEScopeProvider {

	@Inject MuLETypeProvider typeProvider

	override IScope getScope(EObject context, EReference reference) {
		// /*DEBUG*/println(new Object(){}.getClass().getEnclosingMethod().getName())
		var defaultScope = super.getScope(context, reference)
		/*
		 * define which named elements are visible in a feature call
		 * 
		 * a := 2, a is the reference to a named element, which has to be located by the scope provider
		 */
		if (reference == MuLEPackage::eINSTANCE.symbolReference_Symbol) {
			var contextContainer = context.eContainer
			var scope = getVisibleSymbols(contextContainer, context)
			return scope
		}
		/*
		 * define which attributes are visible in the standard notation for composition initializations
		 */
		else if (reference == MuLEPackage::eINSTANCE.symbolRefCompositionAttribute_Attribute) {
			var fc = context.eContainer
			while (!(fc instanceof SymbolReference)) {
				fc = fc.eContainer
			}
			if (fc instanceof SymbolReference) {
				var comp = fc.symbol
				if (comp instanceof Composition) {
					var list = newArrayList
					for (attr : comp.attributes) {
							list.add(attr)
					}
					var superType = comp.superType
					while (superType !== null) {
						for (attr : superType.attributes) {
								list.add(attr)
						}
						superType = superType.superType
					}
					var scope = Scopes.scopeFor(list)
					return scope
				}
			}
			return defaultScope
		}
		/*
		 * define which type declarations are visible as a data type reference
		 * 
		 * typeParameters are added if the referenceContext is contained within a composition
		 */
		else if (reference == MuLEPackage::eINSTANCE.declaredType_Type) {
			var outerScope = scopeForDataTypeReferences(context, reference)
			var list = newArrayList
			var contextContainer = context.eContainer
			while (!(contextContainer instanceof CompilationUnit)) {
				if (contextContainer instanceof Composition) {
					list.addAll(contextContainer.typeParams)
				}
				contextContainer = contextContainer.eContainer
			}
			var scope = Scopes.scopeFor(list, outerScope)
			return scope
		}
		/*
		 * define, which compositions are visible as super type for other compositions
		 */
		else if (reference == MuLEPackage::eINSTANCE.composition_SuperType) {
			var scope = scopeForDataTypeReferences(context, reference)
			return scope
		} 
		return defaultScope
	}

	def IScope scopeForDataTypeReferences(EObject context, EReference reference) {
		// /*DEBUG*/println(new Object(){}.getClass().getEnclosingMethod().getName())
		var defaultScope = super.getScope(context, reference) // get the default scope for the reference
		var temp = context.eContainer
		var list = new ArrayList<EObject>() // temporary list
		var listOfDirectlyVisibleTypes = newArrayList // list of types directly visible in the compUnit
		while (!(temp instanceof CompilationUnit)) {
			temp = temp.eContainer
		}
		var compilationUnit = temp as CompilationUnit
		/*
		 * add imports, and imported visible compositions and enumerations to the temporary list
		 */
		for (_import : compilationUnit.imports) {
			list.add(_import)
			if (_import.importedNamespace !== null)
				for (progElem : _import.importedNamespace.programElements) {
					if (progElem instanceof Composition && (progElem as Composition).visibility === null)
						list.add(progElem)
					if (progElem instanceof Enumeration && (progElem as Enumeration).visibility === null)
						list.add(progElem)
				}
		}
		/*
		 * add compositions and enumerations directly contained in the compUnit to the
		 * temporary list and the list of directly visible types
		 */
		for (progElem : compilationUnit.programElements) {
			if (progElem instanceof Composition) {
				list.add(progElem)
				listOfDirectlyVisibleTypes.add(progElem)
				for (typeDec : progElem.typeDeclarations) {
					if (typeDec instanceof Composition || typeDec instanceof Enumeration) {
						list.add(typeDec)
						listOfDirectlyVisibleTypes.add(typeDec)
					}
				}
			}
			if (progElem instanceof Enumeration) {
				list.add(progElem)
				listOfDirectlyVisibleTypes.add(progElem)
			}
		}
		/*
		 * get all IEObjectDescriptions from the default scope
		 * 
		 * foreach EObject in the temporary list compute the qualified name for each element
		 * 
		 * compare the qualified names for the elements from the default scope and the temporary list
		 * if they are equal, add IEObjectDescription to list2
		 * 
		 * result is the elements from the defaultScope, selected considering their visibility
		 * 
		 */
		var list2 = new ArrayList<IEObjectDescription>()
		var elements = defaultScope.allElements
		for (elem : elements) {
			var name = elem.name.toString
			for (progElem : list) {
				var objName = null as String
				if (progElem instanceof Composition || progElem instanceof Enumeration) {
					objName = (progElem as NamedElement).name
					var container = progElem.eContainer
					while ((container !== null)) {
						if (objName !== null) {
							if (name.equals(objName)) {
								list2.add(elem)
							}
						}
						if (container instanceof Composition) {
							objName = container.name + "." + objName
						}
						if (container instanceof CompilationUnit) {
							objName = container.name + "." + objName
						}
						container = container.eContainer
					}
					if (objName !== null) {
						if (name.equals(objName)) {
							list2.add(elem)
						}
					}
				}
			}
		}
		var qualifiedScope = new SimpleScope(IScope.NULLSCOPE, list2)
		var scope = Scopes.scopeFor(listOfDirectlyVisibleTypes, qualifiedScope)
		return scope
	}

	def listOfVariablesDeclaredBefore(EList<Statement> list, EObject o) {
		// /*DEBUG*/println(new Object(){}.getClass().getEnclosingMethod().getName())
		var index = list.indexOf(o)
		if (index < 0)
			index = 0
		var subList = list.subList(0, index)
		var filteredList = subList.filter(typeof(VariableDeclaration))
		return filteredList
	}

	def listOfVisibleTypes(EObject o) {
		// /*DEBUG*/println(new Object(){}.getClass().getEnclosingMethod().getName())
		var unit = o
		while (!(unit instanceof CompilationUnit) && unit !== null) {
			unit = unit.eContainer
		}
		if (unit === null)
			return null
		if (unit instanceof CompilationUnit) {
			var list = newArrayList
			for (progElem : unit.programElements) {
				if (progElem instanceof Composition /*&& (progElem as Composition).visibility === null */)
					list.add(progElem)
				if (progElem instanceof Enumeration /*&& (progElem as Enumeration).visibility === null */)
					list.add(progElem)
			}
			return list
		}
	}

	def dispatch IScope getVisibleSymbols(EObject cont, EObject o) {
		// /*DEBUG*/println(new Object(){}.getClass().getEnclosingMethod().getName())
		var oCont = o.eContainer
		var contCont = cont.eContainer
		var scope = getVisibleSymbols(contCont, oCont)
		return scope
	}
	
	def dispatch IScope getVisibleSymbols(ListAccess cont, EObject o) {
		// /*DEBUG*/println(new Object(){}.getClass().getEnclosingMethod().getName())
		var contCont = cont.eContainer
		var scope = getVisibleSymbols(contCont, o)
		return scope
	}
	
	def dispatch IScope getVisibleSymbols(OperationInvocation cont, EObject o) {
		// /*DEBUG*/println(new Object(){}.getClass().getEnclosingMethod().getName())
		var contCont = cont.eContainer
		var scope = getVisibleSymbols(contCont, o)
		return scope
	}

	def dispatch IScope getVisibleSymbols(SymbolReference cont, EObject o) {
		// /*DEBUG*/println(new Object(){}.getClass().getEnclosingMethod().getName())
		if (cont.memberCall !== null && !(o.eContainer instanceof ListAccess) && !(o.eContainer instanceof OperationInvocation)) {
			var receiver = cont.symbol
			if (receiver instanceof CompilationUnit) {
				var importedContent = receiver.programElements
				var visibleContent = newArrayList
				for (progElem : importedContent) {
					if (progElem instanceof Operation && (progElem as Operation).visibility === null)
						visibleContent.add(progElem)
					if (progElem instanceof Composition && (progElem as Composition).visibility === null)
						visibleContent.add(progElem)
					if (progElem instanceof Enumeration && (progElem as Enumeration).visibility === null)
						visibleContent.add(progElem)
				}
				var scope = Scopes::scopeFor(visibleContent)
				return scope
			}
			if (receiver instanceof Enumeration) {
				var list = new ArrayList<EObject>()
				list.addAll(receiver.values)
				var scope = Scopes::scopeFor(list)
				return scope
			}
			if (receiver instanceof Composition && cont.compositionInit !== null) {
				var list = new ArrayList<EObject>()
				for (attr : (receiver as Composition).attributes) {
					if (attr.visibility === null) {
						list.add(attr)
					}
				}
				for (op : (receiver as Composition).operations) {
					if (op.visibility === null) {
						list.add(op)
					}
				}
				var scope = Scopes::scopeFor(list)
				return scope
			}
			if (receiver instanceof Feature) {
				var type = typeProvider.typeFor2(cont)
				if (type instanceof DeclaredType) {
					var typeType = type.type
					if (typeType instanceof Composition) {

						// compute, whether the reference is contained in an inheritance hierarchy
						// needed to define if a protected member can be referenced
						var statement = getContainingStatement(cont)
						var container = statement.eContainer
						var canBeReferenced = false
						while (!(container instanceof CompilationUnit)) {
							if (container instanceof Composition && container === typeType)
								canBeReferenced = true
							container = container.eContainer
						}

						var list = new ArrayList<EObject>()
						for (attr : typeType.attributes) {
							if (attr.visibility === null || attr.visibility.equals("protected") && canBeReferenced) {
								list.add(attr)
							}
						}
						for (op : typeType.operations) {
							if (op.visibility === null || op.visibility.equals("protected") && canBeReferenced) {
								list.add(op)
							}
						}
						var superType = typeType.superType
						while (superType !== null) {
							for (attr : superType.attributes) {
								if (attr.visibility === null ||
									attr.visibility.equals("protected") && canBeReferenced) {
									list.add(attr)
								}
							}
							for (op : superType.operations) {
								if (op.visibility === null || op.visibility.equals("protected") && canBeReferenced) {
									list.add(op)
								}
							}
							superType = superType.superType
						}
						var scope = Scopes::scopeFor(list)
						return scope
					}
					if (typeType instanceof TypeParameter) {
						var list = new ArrayList<EObject>()
						var composition = typeType.superType
						while (composition !== null) {
							list.addAll(composition.typeDeclarations)
							list.addAll(composition.attributes)
							list.addAll(composition.operations)
							composition = composition.superType
						}
						var scope = Scopes::scopeFor(list)
						return scope
					}
				}
			}
		} else {
			var statement = getContainingStatement(cont)
			var block = statement.eContainer as Block
			var visibleElements = new ArrayList<NamedElement>
			visibleElements.addAll(listOfVariablesDeclaredBefore(block.statements, statement))
			var scope = Scopes.scopeFor(visibleElements, getVisibleSymbols(block, o))
			return scope
		}
		var scope = IScope.NULLSCOPE
		return scope
	}

	def Statement getContainingStatement(Expression e) {
		// /*DEBUG*/println(new Object(){}.getClass().getEnclosingMethod().getName())
		var cont = e.eContainer
		if (cont instanceof Block)
			return e as Statement
		while (!(cont.eContainer instanceof Block)) {
			cont = cont.eContainer
		}
		return cont as Statement
	}

	def dispatch IScope getVisibleSymbols(Block block, EObject o) {
		// /*DEBUG*/println(new Object(){}.getClass().getEnclosingMethod().getName())
		var list = new ArrayList<EObject>()
		list.addAll(block.statements.listOfVariablesDeclaredBefore(o))
		var blockContainer = block.eContainer
		if (blockContainer instanceof LambdaExpression)
			list.addAll(blockContainer.parameters)
		if (blockContainer instanceof LetStatement)
			list.add(blockContainer.variable)
		if (blockContainer instanceof ElseLet)
			list.add(blockContainer.variable)
		if (blockContainer instanceof Operation) {
			var op = blockContainer as Operation
			list.addAll(op.params)
			var container = op.eContainer
			while (container instanceof Composition) { // nested compositions
				var composition = container as Composition
				list.addAll(composition.typeDeclarations)
				list.addAll(composition.attributes)
				list.addAll(composition.operations)
				var superType = composition.superType
				while (superType !== null) {
					for (typeDec : superType.typeDeclarations) {
						if (typeDec instanceof Composition && ((typeDec as Composition).visibility === null ||
							(typeDec as Composition).visibility.equals("protected"))) {
							list.add(typeDec)
						}
						if (typeDec instanceof Enumeration && ((typeDec as Enumeration).visibility === null ||
							(typeDec as Enumeration).visibility.equals("protected"))) {
							list.add(typeDec)
						}
					}
					for (attr : superType.attributes) {
						if (attr.visibility === null || attr.visibility.equals("protected")) {
							list.add(attr)
						}
					}
					for (op2 : superType.operations) {
						if (op2.visibility === null || op2.visibility.equals("protected")) {
							list.add(op2)
						}
					}
					superType = superType.superType
				}
				container = container.eContainer 
			}
		}
		if (blockContainer instanceof ElseIf)
			blockContainer = blockContainer.eContainer
		Scopes::scopeFor(list, getVisibleSymbols(blockContainer.eContainer, blockContainer))
	}

	def dispatch IScope getVisibleSymbols(CompilationUnit p, EObject o) {
		// /*DEBUG*/println(new Object(){}.getClass().getEnclosingMethod().getName())
		var list = new ArrayList<NamedElement>()
		for (imp : p.imports) {
			var nameSpace = imp.importedNamespace
			list.add(nameSpace)
		}
		list.addAll(p.programElements.filter(typeof(Operation)))
		for (elem : listOfVisibleTypes(p))
			if (elem instanceof NamedElement)
				list.add(elem)
		list.add(p)
		Scopes::scopeFor(list)
	}

}

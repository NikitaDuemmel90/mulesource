/*
 * generated by Xtext 2.16.0
 */
package de.ubt.ai1.mule.ui.quickfix

import com.google.inject.Inject
import de.ubt.ai1.mule.muLE.CompilationUnit
import de.ubt.ai1.mule.muLE.Composition
import de.ubt.ai1.mule.muLE.DataType
import de.ubt.ai1.mule.muLE.MuLEFactory
import de.ubt.ai1.mule.muLE.Operation
import de.ubt.ai1.mule.muLE.Parameter
import de.ubt.ai1.mule.muLE.SymbolReference
import de.ubt.ai1.mule.validation.MuLETypeValidator
import de.ubt.ai1.mule.validation.MuLEValidator
import mule.util.MuLEObjectCopyProvider
import mule.util.Util
import org.eclipse.xtext.ui.editor.quickfix.DefaultQuickfixProvider
import org.eclipse.xtext.ui.editor.quickfix.Fix
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor
import org.eclipse.xtext.validation.Issue
import de.ubt.ai1.mule.muLE.LambdaExpression

/**
 * Custom quickfixes.
 * 
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#quick-fixes
 */
class MuLEQuickfixProvider extends DefaultQuickfixProvider { 
	@Inject extension MuLEObjectCopyProvider

	@Fix(MuLEValidator.ERROR_NO_RETURN)
	def returnAdd(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Add a return statement.', 'Add a return statement.', null) [ element, context |
			if (element instanceof Operation) {
				(element as Operation).block.statements.add(MuLEFactory.eINSTANCE.createReturnStatement)
			} else if (element instanceof LambdaExpression) {
				(element as LambdaExpression).block.statements.add(MuLEFactory.eINSTANCE.createReturnStatement)
			} 
		]
	}

	@Fix(MuLEValidator.ERROR_INTEGER_STARTS_WITH_ZERO)
	def fixIntegerStartsWithZeros(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Remove starting zeroes.', 'Remove starting zeroes.', null) [ element, context |
			val xtextDocument = context.xtextDocument
			val issueString = xtextDocument.get(issue.offset, issue.length)
			var newString = issueString
			while (newString.startsWith("0")) {
				newString = newString.replaceFirst("0", "")
			}
			xtextDocument.replace(issue.offset, issue.length, newString)
		]
	}

	@Fix(MuLEValidator.ERROR_RATIONAL_STARTS_WITH_ZERO)
	def fixRationalStartsWithZeros(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Remove starting zeroes.', 'Remove starting zeroes.', null) [ element, context |
			val xtextDocument = context.xtextDocument
			val issueString = xtextDocument.get(issue.offset, issue.length)
			var newString = issueString
			while (newString.startsWith("0")) {
				newString = newString.replaceFirst("0", "")
			}
			xtextDocument.replace(issue.offset, issue.length, newString)
		]
	}

	@Fix(MuLEValidator.ERROR_ASSIGNMENT_TO_OPERATION)
	def fixAssignmentToOperation(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Remove assignment.', 'Remove assignment.', null) [ element, context |
			val xtextDocument = context.xtextDocument
			val issueString = xtextDocument.get(issue.offset, issue.length)
			var newString = issueString.split(":=").get(0)
			xtextDocument.replace(issue.offset, issue.length, newString)
		]
	}

	@Fix(MuLEValidator.ERROR_CYCLIC_INHERITANCE)
	def fixCyclicInheritance(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Remove cyclic inheritance.', 'Remove cyclic inheritance.', null) [ element, context |
			val xtextDocument = context.xtextDocument
			xtextDocument.replace(issue.offset, issue.length, "")
		]
	}

	@Fix(MuLEValidator.ERROR_UNIMPLEMENTED_OPERATIONS)
	def fixUnimplementedOperations(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Add unimplemented operations.', 'Add unimplemented operations.', null) [ element, context |
			/* get a list of inherited abstract operations */
			var c = element as Composition
			var inheritedAbstractOps = newArrayList
			var superType = c.superType
			while (superType !== null) {
				for (op : superType.operations) {
					if (op.abstract) {
						inheritedAbstractOps.add(op)
					}
				}
				superType = superType.superType
			}
			// filter out abstract operations already implemented in super types
			superType = c.superType
			while (superType !== null) {
				for (op : superType.operations) {
					if (!op.abstract) {
						inheritedAbstractOps.remove(op)
					}
				}
				superType = superType.superType
			}
			/* check if the inherited operations are implemented */
			var unimplementedOps = newArrayList
			var ops = newArrayList
			for (op : c.operations) {
				ops.add(op)
			}
			for (inheritedOp : inheritedAbstractOps) {
				if (!ops.contains(inheritedOp)) {
					unimplementedOps.add(inheritedOp)
				}
			}
			for (unimOp : unimplementedOps) {
				var newOp = MuLEObjectCopyProvider.copyMuLEObject(unimOp) as Operation
				newOp.override = true
				newOp.abstract = false
				newOp.block = MuLEFactory.eINSTANCE.createBlock
				c.operations.add(newOp)
			}
		]
	}

	@Fix(MuLEValidator.ERROR_MISSING_INHERITED_TYPE_PARAMETERS)
	def fixMissingInheritedTypeParameters(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Add missing type parameters.', 'Add missing type parameters.', null) [ element, context |
			var c = element as Composition
			var superType = c.superType
			var inheritedTypeParams = newArrayList
			while (superType !== null && superType !== c) {
				inheritedTypeParams.addAll(superType.typeParams)
				superType = superType.superType
			}
			var inheritedTypeParamsNames = newArrayList
			for (inhTP : inheritedTypeParams) {
				inheritedTypeParamsNames.add(inhTP.name)
			}
			var ownTypeParamsNames = newArrayList
			for (ownTP : c.typeParams) {
				ownTypeParamsNames.add(ownTP.name)
			}
			for (inhTPName : inheritedTypeParamsNames) {
				if (!ownTypeParamsNames.contains(inhTPName)) {
					var tp = MuLEFactory.eINSTANCE.createTypeParameter
					tp.name = inhTPName
					c.typeParams.add(tp)
				}
			}
		]
	}

	@Fix(MuLEValidator.ERROR_MISSING_OUTER_TYPE_PARAMETERS)
	def fixMissingOuterTypeParameters(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Add missing type parameters.', 'Add missing type parameters.', null) [ element, context |
			var c = element as Composition
			if (c.eContainer instanceof Composition) {				
				var container = c.eContainer as Composition
				var ownTypeParamsNames = newArrayList
				for (ownTP : c.typeParams) {
					ownTypeParamsNames.add(ownTP.name)
				}
				for (otp : container.typeParams) {
					if (!ownTypeParamsNames.contains(otp.name)) {
						var tp = MuLEFactory.eINSTANCE.createTypeParameter
						tp.name = otp.name
						c.typeParams.add(tp)
					}
				}
			}
		]
	}

	@Fix(MuLEValidator.ERROR_OPERATION_BOTH_ABSTRACT_AND_OVERRIDE)
	def fixOperationBothAbstractAndOverride(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Remove override keyword.', 'Remove override keyword.', null) [ element, context |
			var op = element as Operation
			op.override = false
		]
	}

	@Fix(MuLEValidator.ERROR_OPERATION_BOTH_ABSTRACT_AND_OVERRIDE)
	def fixOperationBothAbstractAndOverride2(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Remove abstract keyword.', 'Remove abstract keyword.', null) [ element, context |
			var op = element as Operation
			op.abstract = false
		]
	}

	@Fix(MuLEValidator.ERROR_ABSTRACT_OPERATION_IN_NON_ABSTRACT_TYPE)
	def fixAbstactOpInNonAbstractType(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Remove abstract keyword.', 'Remove abstract keyword.', null) [ element, context |
			var op = element as Operation
			op.abstract = false
		]
	}

	@Fix(MuLEValidator.ERROR_ABSTRACT_OPERATION_IN_COMPILATION_UNIT)
	def fixAbstractOpInCompilationUnit(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Remove abstract keyword.', 'Remove abstract keyword.', null) [ element, context |
			var op = element as Operation
			op.abstract = false
			if (op.block === null)
				op.block = MuLEFactory.eINSTANCE.createBlock
		]
	}

	@Fix(MuLEValidator.ERROR_ABSTRACT_OPERATION_HAS_BODY)
	def fixAbstractOpHasBody(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Remove abstract keyword.', 'Remove abstract keyword.', null) [ element, context |
			var op = element as Operation
			op.abstract = false
		]
	}

	@Fix(MuLEValidator.ERROR_ABSTRACT_OPERATION_HAS_BODY)
	def fixAbstractOpHasBody2(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Remove operation body.', 'Remove operation body.', null) [ element, context |
			var op = element as Operation
			op.block = null
		]
	}

	@Fix(MuLEValidator.ERROR_NON_ABSTRACT_OPERATION_HAS_NO_BODY)
	def fixNonAbstractOpHasNoBody(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Add operation body.', 'Add operation body.', null) [ element, context |
			var op = element as Operation
			op.block = MuLEFactory.eINSTANCE.createBlock
		]
	}

	@Fix(MuLEValidator.ERROR_OVERRIDE_IN_NON_OVERRIDING_OPERATION)
	def fixOverrideInNonOverridingOp(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Remove override keyword.', 'Remove override keyword.', null) [ element, context |
			var op = element as Operation
			op.override = false
		]
	}

	@Fix(MuLEValidator.ERROR_NO_OVERRIDE_IN_OVERRIDING_OPERATION)
	def fixNoOverrideInOverridingOp(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Add override keyword.', 'Add override keyword.', null) [ element, context |
			var op = element as Operation
			op.override = true
		]
	}

	@Fix(MuLEValidator.ERROR_DIFFERENT_VISIBILITY_OF_OVERRIDING_OPERATION)
	def fixDifferentVisibilityOfOverridingOp(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Change visibility.', 'Change visibility.', null) [ element, context |
			var op = element as Operation
			var container = op.eContainer as Composition
			var superType = container.superType
			var matched = false
			while (superType !== null && !matched) {
				for (inhOp : superType.operations) {
					if (inhOp.name.equals(op.name)) {
						matched = true
						op.visibility = inhOp.visibility
					}
				}
				superType = superType.superType
			}
		]
	}

	@Fix(MuLEValidator.ERROR_OVERRIDING_OPERATION_DIFFERENT_PARAMETERS)
	def fixOverridingOpDifferentParams(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Change parameter profile.', 'Change parameter profile.', null) [ element, context |
			var op = element as Operation
			var container = op.eContainer as Composition
			var superType = container.superType
			var matched = false
			while (superType !== null && !matched) {
				for (inhOp : superType.operations) {
					if (inhOp.name.equals(op.name)) {
						matched = true
						op.params.clear
						for (p : inhOp.params) {
							op.params.add(MuLEObjectCopyProvider.copyMuLEObject(p) as Parameter)
						}
					}
				}
				superType = superType.superType
			}
		]
	}

	@Fix(MuLEValidator.ERROR_OVERRIDING_OPERATION_DIFFERENT_RETURN_TYPE)
	def fixOverridingOpDifferentReturnType(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Change return type.', 'Change return type.', null) [ element, context |
			var op = element as Operation
			var container = op.eContainer as Composition
			var superType = container.superType
			var matched = false
			while (superType !== null && !matched) {
				for (inhOp : superType.operations) {
					if (inhOp.name.equals(op.name)) {
						matched = true
						op.type = MuLEObjectCopyProvider.copyMuLEObject(inhOp.type) as DataType
					}
				}
				superType = superType.superType
			}
		]
	}

	@Fix(MuLEValidator.ERROR_ILLEGAL_OVERRIDE)
	def fixIllegalOverride(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Remove override keyword.', 'Remove override keyword.', null) [ element, context |
			var op = element as Operation
			op.override = false
		]
	}

	@Fix(MuLEValidator.ERROR_PROGRAM_HAS_NO_MAIN)
	def fixProgramHasNoMain(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Add the main procedure.', 'Add the main procedure.', null) [ element, context |
			var p = element as CompilationUnit
			p.main = MuLEFactory.eINSTANCE.createMainProcedure
			p.main.block = MuLEFactory.eINSTANCE.createBlock
		]
	}

	@Fix(MuLEValidator.ERROR_PROGRAM_HAS_NO_MAIN)
	def fixProgramHasNoMain2(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Change to library.', 'Change to library.', null) [ element, context |
			var p = element as CompilationUnit
			p.isProgram = false
			p.isLibrary = true
		]
	}

	@Fix(MuLEValidator.ERROR_LIBRARY_HAS_MAIN)
	def fixLibHasMain(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Change to program.', 'Change to program.', null) [ element, context |
			var p = element as CompilationUnit
			p.isLibrary = false
			p.isProgram = true
		]
	}

	@Fix(MuLEValidator.ERROR_LIBRARY_HAS_MAIN)
	def fixLibHasMain2(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Remove the main procedure.', 'Remove the main procedure.', null) [ element, context |
			var p = element as CompilationUnit
			p.main = null
		]
	}

	@Fix(MuLEValidator.ERROR_FILE_NAME_DIFFERENT)
	def fixFileNameDifferent(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Change name.', 'Change name.', null) [ element, context |
			var p = element as CompilationUnit
			var name = p.eResource.URI.trimFileExtension.lastSegment
			p.name = name
		]
	}

	@Fix(MuLEValidator.ERROR_INCORRECT_ATTRIBUTE_SEQUENCE)
	def fixIncorrectAttrSequence(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Change to an empty composition initialization construct.',
			'Change to an empty composition initialization construct.', null) [ element, context |
			val xtextDocument = context.xtextDocument
			xtextDocument.replace(issue.offset, issue.length, "{}")
		]
	}

	@Fix(MuLEValidator.ERROR_INCORRECT_ATTRIBUTE_SEQUENCE)
	def fixIncorrectAttrSequence2(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Change to an non-empty composition initialization construct.',
			'Change to an non-empty composition initialization construct.', null) [ element, context |
			val xtextDocument = context.xtextDocument
			val fc = element.eContainer as SymbolReference
			var expectedAttributes = Util.getListOfPublicAttributesInInheritanceRelation(fc.symbol as Composition)
			var newString = "{"
			for (attr : expectedAttributes) {
				newString += attr.name + " = EXPRESSION"
				if (expectedAttributes.last !== attr) {
					newString += ", "
				}
			}
			newString += "}"
			xtextDocument.replace(issue.offset, issue.length, newString)
		]
	}

	@Fix(MuLEValidator.ERROR_ILLEGAL_VISIBILITY)
	def fixIllegalVisibility(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Remove the visibility modifier.', 'Remove the visibility modifier.', null) [ element, context |
			val xtextDocument = context.xtextDocument
			xtextDocument.replace(issue.offset, issue.length, "")
		]
	}

	@Fix(MuLETypeValidator.ERROR_ILLEGAL_RETURN_NO_VALUE)
	def returnAddValue(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Add a value placeholder to the return statement.',
			'Add a value placeholder to the return statement.', null) [ element, context |
			val xtextDocument = context.xtextDocument
			val issueString = xtextDocument.get(issue.offset, issue.length)
			val newString = issueString + " __INSERT_VALUE_HERE__"
			xtextDocument.replace(issue.offset, issue.length, newString)
		]
	}

	@Fix(MuLETypeValidator.ERROR_ILLEGAL_RETURN)
	def returnRemoveValue(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Remove the returned value.', 'Remove the returned value.', null) [ element, context |
			val xtextDocument = context.xtextDocument
			xtextDocument.replace(issue.offset, issue.length, "")
		]
	}

	@Fix(MuLETypeValidator.ERROR_SHOULD_BE_REFERENCE_TYPE)
	def fixInvalidUseOfAbstractType(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Change to a reference type.', 'Change to a reference type.', null) [ element, context |
			val xtextDocument = context.xtextDocument
			val issueString = xtextDocument.get(issue.offset, issue.length)
			val newString = "reference<" + issueString + ">"
			xtextDocument.replace(issue.offset, issue.length, newString)
		]
	}

	@Fix(MuLETypeValidator.ERROR_COMPOSITION_INIT_REQUIRED)
	def fixCompositionInitRequired(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Add an empty composition initialization construct.',
			'Add an empty composition initialization construct.', null) [ element, context |
			val xtextDocument = context.xtextDocument
			val issueString = xtextDocument.get(issue.offset, issue.length)
			var newString = issueString + "{}"
			xtextDocument.replace(issue.offset, issue.length, newString)
		]
	}

	@Fix(MuLETypeValidator.ERROR_COMPOSITION_INIT_REQUIRED)
	def fixCompositionInitRequired2(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Add a non-empty composition initialization construct.',
			'Add a non-empty composition initialization construct.', null) [ element, context |
			val xtextDocument = context.xtextDocument
			val issueString = xtextDocument.get(issue.offset, issue.length)
			val fc = element as SymbolReference
			var expectedAttributes = Util.getListOfPublicAttributesInInheritanceRelation(fc.symbol as Composition)
			var newString = issueString + "{"
			for (attr : expectedAttributes) {
				newString += attr.name + " = EXPRESSION"
				if (expectedAttributes.last !== attr) {
					newString += ", "
				}
			}
			newString += "}"
			xtextDocument.replace(issue.offset, issue.length, newString)
		]
	}

	@Fix(MuLETypeValidator.ERROR_ACCESS_MODIFIER_NOT_ALLOWED)
	def fixAccessModifierNotAllowed(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Remove access modifiers.', 'Remove access modifiers.', null) [ element, context |
			val xtextDocument = context.xtextDocument
			xtextDocument.replace(issue.offset, issue.length, "")
		]
	}

	@Fix(MuLETypeValidator.ERROR_COMPOSITION_INIT_NOT_ALLOWED)
	def fixCompositionInitNotAllowed(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Remove the composition initialization construct.',
			'Remove the composition initialization construct.', null) [ element, context |
			val xtextDocument = context.xtextDocument
			xtextDocument.replace(issue.offset, issue.length, "")
		]
	}

	@Fix(MuLETypeValidator.ERROR_OPERATION_REQUIRES_PARAMETER_PROFILE)
	def fixOperationRequiresParameterProfile(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Add parameters.', 'Add parameters.', null) [element, context |
			val xtextDocument = context.xtextDocument
			var op = (element as SymbolReference).symbol as Operation
			var newString = xtextDocument.get(issue.offset, issue.length) + "("
			for (p : op.params) {
				newString += "EXPRESSION"
				if (op.params.last !== p) 
					newString += ", "
			}
			newString += ")"
			xtextDocument.replace(issue.offset, issue.length, newString)
		]
	}

	@Fix(MuLETypeValidator.ERROR_ILLEGAL_ACCESS_MODIFIER)
	def fixIllegalDereference(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Remove the access modifier.', 'Remove the access modifier.', null) [element, context |
			val xtextDocument = context.xtextDocument
			xtextDocument.replace(issue.offset, issue.length, "")
		]
	}

//	@Fix(MuLETypeValidator.ERROR_INCOMPATIBLE_TYPE_PARAMETER)
//	def fixIncompatibleTypeParameter(Issue issue, IssueResolutionAcceptor acceptor) {
//		acceptor.accept(issue, '.', '.', null) [element, context |
//		]
//	}
//	@Fix(MuLEValidator.INVALID_NAME)
//	def capitalizeName(Issue issue, IssueResolutionAcceptor acceptor) {
//		acceptor.accept(issue, 'Capitalize name', 'Capitalize the name.', 'upcase.png') [
//			context |
//			val xtextDocument = context.xtextDocument
//			val firstLetter = xtextDocument.get(issue.offset, 1)
//			xtextDocument.replace(issue.offset, 1, firstLetter.toUpperCase)
//		]
//	}
}

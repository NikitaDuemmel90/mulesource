/*
 * generated by Xtext 2.16.0
 */
package de.ubt.ai1.mule.ui.wizard

import org.eclipse.jdt.core.JavaCore
import org.eclipse.xtext.builder.impl.XtextBuilder
import org.eclipse.xtext.ui.XtextProjectHelper
import org.eclipse.xtext.ui.util.JREContainerProvider
import org.eclipse.xtext.ui.util.PluginProjectFactory
import org.eclipse.xtext.ui.wizard.template.IProjectGenerator
import org.eclipse.xtext.ui.wizard.template.IProjectTemplateProvider
import org.eclipse.xtext.ui.wizard.template.ProjectTemplate

/**
 * Create a list with all project templates to be shown in the template new project wizard.
 * 
 * Each template is able to generate one or more projects. Each project can be configured such that any number of files are included.
 */
class MuLEProjectTemplateProvider implements IProjectTemplateProvider {
	override getProjectTemplates() {
		#[new EmptyProject]
	}
}

@ProjectTemplate(label="Empty Project", icon="project_template.png", description="<p><b>Empty Project</b></p>
<p>This is a clean MuLE project. You have to create new MuLE files via the new file wizard in the src folder to start programming.</p>")
final class EmptyProject {
//	val advanced = check("Advanced:", false)
//	val advancedGroup = group("Properties")
//	val name = combo("Name:", #["Xtext", "World", "Foo", "Bar"], "The name to say 'Hello' to", advancedGroup)
//	val path = text("Package:", "mydsl", "The package path to place the files in", advancedGroup)
//
//	override protected updateVariables() {
//		name.enabled = advanced.value
//		path.enabled = advanced.value
//		if (!advanced.value) {
//			name.value = "Xtext"
//			path.value = "ampl"
//		}
//	}
//
//	override protected validate() {
////		if (projectInfo.projectName.matches('[a-z][a-z0-9_]*(/[a-z][a-z0-9_]*)*'))
//		if (projectInfo.projectName.equals("ASDF")){
//			System.out.println(projectInfo.projectName)
//			null
//		}
//		else
//			new Status(ERROR, "Wizard", "'" + projectInfo.projectName + "' is not a valid project name")
//	}
	override generateProjects(IProjectGenerator generator) {

//		if (projectInfo.projectName.matches('[a-z][a-z0-9_]*(/[a-z][a-z0-9_]*)*'))
		val bree = "JavaSE-1.8"
		generator.generate(new PluginProjectFactory => [
			projectName = projectInfo.projectName
			location = projectInfo.locationPath
			projectNatures += #[JavaCore.NATURE_ID, "org.eclipse.pde.PluginNature", XtextProjectHelper.NATURE_ID]
			builderIds += #[JavaCore.BUILDER_ID, XtextBuilder.BUILDER_ID]
			requiredBundles += "de.ubt.ai1.mule"
			exportedPackages += "generated"
			folders += #["src", "src-gen"]
			breeToUse = bree
			jreContainerEntry = JREContainerProvider.getJREContainerEntry(bree)
			addFile('''---HELP---/1.00 - Libraries.txt''', '''
				In order to use a library operation the library must first be imported.
				
				---EXAMPLE---
				
				import IO		 					// Import IO library
				
				main
					IO.writeString("Hello, world!") // call the writeString Operation from the imported library IO
					
					variable text : string 			// declare a string type variable
					text := IO.readString()			// call the readString Operation, the entered value is saved in the text variable
					IO.writeString(text) 			// call the writeString Operation to print the previously entered value
				endmain		
				
			''')
			addFile('''---HELP---/1.01 - IO.txt''', '''
				library IO
				
				
				operation writeLine()
					causes a linebreak
					 
				
				operation writeString(parameter arg : string) 
					prints a string value on the console
				
				
				operation writeInteger(parameter arg : integer) 
					prints an integer value on the console
				
				
				operation writeRational(parameter arg : rational) 
					prints a rational value on the console
				
				
				operation writeBoolean(parameter arg : boolean) 
					prints a boolean value on the console
				
				
				operation readString() : string
					reads a string value from the console
				
				
				operation readInteger() : integer
					reads an integer value from the console
				
				
				operation readBoolean() : boolean
					reads a boolean value from the console
				
				
				operation readRational() : rational
					reads a rational value from the console
				
				
				operation writeFile(path : string, content : string) 
					creates a file with the given path and the string content. 
					If a file under the given path already exists, its content is overwritten. 
					The entered path can be relative to the project, or absolute.
				
				
				operation readFile(path : string) : string) 
					reads a file under the given path and returns its contents as a string. 
				
				
				operation readFileLines(path : string) : list<string> 
					reads a file under the given path and returns its contents as a list of strings, 
					wherein each entry of the list is a single line of the file. 
			''')
			addFile('''---HELP---/1.02 - Strings.txt''', '''
				library Strings
				
				
				operation subString(parameter str : string, parameter startPos : integer, parameter endPos : integer) : string
					Returns a substring from a passed string according to inclusive boundaries set by startPos and endPos values.
					Strings.subString("Hello", 1, 3) will return "ell" as value.
					
					
				operation lengthOf(parameter str : string) : integer
					Returns the number of characters in a string value.
					Strings.lengthOf("Hello") will return 5 as value.
				
					
				operation indexOfSubString(parameter str : string, parameter subStr : string) : integer
					Returns the position of the first encountered substring in a string value.
					Strings.indexOfSubString("Hello", "l") will return 2 as value.
				
				
				operation replaceAll(parameter str : string, parameter regex : string, parameter replacement : string) : string
					Returns a version of the passed string value where all occurrences of the regex are replaced with the replacement.
					Strings.replaceAll("Hello", "l", "L") will return "HeLLo" as value.
					
					
				operation replaceFirst(parameter str : string, parameter regex : string, parameter replacement : string) : string
					Returns a version of the passed string value where the first occurrence of the regex is replaced with the replacement.
					Strings.replaceAll("Hello", "l", "L") will return "HeLlo" as value.
					
					
				operation split(parameter str : string, parameter regex : string) : list<string>
					Splits the given string str into a list of substrings at all occurrences of the passed substring regex.
					Strings.split("a:b:c:d", ":") returns [a, b, c, d] as value.
					
				
				operation toLowerCase(parameter str : string) : string
					Returns a version of the passed string value with all lower case characters (if possible).
				
				
				operation toUpperCase(parameter str : string) : string
					Returns a version of the passed string value with all upper case characters (if possible).
				
				
				operation integerToString(parameter num : integer) : string
					Converts an integer value to a string value.
				
				
				operation rationalToString(parameter num : rational) : string
					Converts a rational value to a string value.
				
				
				operation booleanToString(parameter num : boolean) : string
					Converts a boolean value to a string value.
				
				
				operation genericToString(parameter object : DataType) : string
					Converts a value of any type to a string value.
					Has to be used when lists, references, compositions and enumerations must be converted to string.
					Good luck explaining why other conversion operations exist.
				
			''')
			addFile('''---HELP---/1.03 - Lists.txt''', '''
				library Lists
				
				
				operation isEmpty(parameter _list : list<T>) : boolean
					Returns true if the passed list is empty, false otherwise.
					
					
				operation lengthOf(parameter _list : list<T>) : integer
					Returns the number of elements in a list.
					
					
				operation indexOf(parameter _list : list<T>, parameter elem : T) : integer
					Returns the position of an element in a list.
					
					
				operation append(parameter _list : list<T>, parameter elem : T) : list<T>
					Appends an element to a list and returns the new list, doesn't change the value of the passed list.
					
						
				operation head(parameter _list : list<T>) : T
					Returns the first element in a list.
					
					
				operation tail(parameter _list : list<T>) : list<T>
					Returns the list without the first element.
					
					
				operation last(parameter _list : list<T>) : T
					Returns the last element in a list.
					
					   
				operation subList(parameter _list : list<T>, parameter min : integer, parameter max : integer) : list<T>
					Returns a sublist from a passed list according to the boundaries set by min and max values.
					
					   
				operation insert(parameter _list : list<T>, parameter elem : T, parameter pos : integer) : list<T>
					Inserts an element at a position in a list, does not overwrite previous element at that position.
					
					
				operation removeElement(parameter _list : list<T>, parameter elem : T) : list<T>
					Removes the first encountered element with the passed value in a list.
					
					
				operation removePosition(parameter _list : list<T>, parameter pos : integer) : list<T>
					Removes an element at the passed position in a list.
					
					
				operation filter(parameter _list : list<DataType>, parameter op : operation(DataType) : boolean) : list<Type>
					Returns a list with copies of entries of the original list, which fulfil the condition specified by the passed operation.
				
				
				operation forEach(parameter _list : list<DataType>, parameter op : operation(DataType)) 
					Applies the passed operation to each entry of the passed list in order of their appearance.
			''')
			addFile('''---HELP---/1.04 - Mathematics.txt''', '''
				library Mathematics
				
				
				operation randomInteger(parameter min : integer, parameter max : integer) : integer
					Generated a random integer value in the [min .. max] (inclusive) range.
					
				
				operation randomRational() : rational
					Generated a random rational value in the [0.0 .. 1.0] (exclusive) range.				
				
				
				operation pi() : rational
					Returns an approximation of the PI constant.
				
				
				operation e() : rational
					Returns an approximation of the E constant.
				
				
				operation sin(parameter a : rational) : rational
					Returns the value of the sinus function of an angle (radians).
				
				
				operation cos(parameter a : rational) : rational
					Returns the value of the cosinus function of an angle (radians).
				
				
				operation tan(parameter a : rational) : rational
					Returns the value of the tangens function of an angle (radians).
				
				
				operation asin(parameter a : rational) : rational
					Returns the value of the arcus sinus function of an angle (radians).
				
				
				operation acos(parameter a : rational) : rational
					Returns the value of the arcus cosinus function of an angle (radians).
				
				
				operation atan(parameter a : rational) : rational
					Returns the value of the arcus tangens function of an angle (radians).
				
				
				operation log(parameter a : rational) : rational
					Returns the logarithmic value with the base of E.
				
				
				operation log10(parameter a : rational) : rational
					Returns the logarithmic value with the base of 10.
				
				
				operation round(parameter a : rational) : integer
					Returns the rounded integer value of a rational parameter.
				
				
				operation floor(parameter a : rational) : integer
					Returns the integer value of a rational parameter without the floating point part.
				
				
				operation absoluteInteger(parameter a : integer) : integer
					Returns the the absolute value of an integer parameter.
				
				
				operation absoluteRational(parameter a : rational) : rational
					Returns the the absolute value of a rational parameter.
				
				
				operation toDegrees(parameter a : rational) : rational
					Converts an angle to degree representation.
				
				
				operation toRadians(parameter a : rational) : rational
					Converts an angle to radians representation.
				
				
				operation getMaxIntegerValue() : integer
				 	Returns the biggest supported integer value
				
				
				operation getMinIntegerValue() : integer
				 	Returns the smallest supported integer value
				
				
				operation getMaxRationalValue() : rational
				 	Returns the biggest positive supported rational value
				
				
				operation getMinRationalValue() : rational
				 	Returns the smallest positive supported rational value
				
			''')
			addFile('''---HELP---/1.05 - Turtle.txt''', '''
				library Turtle
				
				type Speed : enumeration
					SLOW, MEDIUM, FAST, INSTANT
				endtype
				
				type Colors : enumeration 
					WHITE, BLACK, RED, GREEN, BLUE, YELLOW, MAGENTA, CYAN, PINK, ORANGE, LIGHT_GRAY, DARK_GRAY
				endtype
				
				type Orientation : enumeration
					NORTH, SOUTH, EAST, WEST
				endtype
				
				operation forward(parameter length : integer)
					Draws forward a straight line with the passed length in pixels.
				
				operation backward(parameter length : integer)
					Draws backward a straight line with the passed length in pixels.
				
				operation right(parameter degree : rational)
					Changes orientation to the rigth.
				
				operation left(parameter degree : rational)
					Changes orientation to the left.
				
				operation penUp()
					Stops drawing when issuing forward or backward calls.
				
				operation penDown()
					Stops drawing again if penUp was called earlier.
				
				operation setColor(parameter color : Colors)
					Sets the color to one of the predefined colors.
					WHITE, BLACK, RED, GREEN, BLUE, YELLOW, MAGENTA, CYAN, PINK, ORANGE, LIGHT_GRAY, DARK_GRAY
				
				operation setColorRGB(parameter r : integer, parameter g : integer, parameter b : integer)
					Sets the color using rgb values.
				
				operation setThickness(parameter thickness : integer)
					Sets the thickness of lines in pixels.
				
				operation setPosition(parameter x : integer, parameter y : integer)
					Sets the position of the cursor. (0, 0) is located in the upper left corner of the frame.
				
				operation setOrientation(parameter o : Orientation)
					Sets the orientation of the cursor to a predefined value.
					NORTH, SOUTH, EAST, WEST
				
				operation setFrameSize(parameter x : integer, parameter y : integer)
					Sets the size of the frame in pixels.
				
				operation startFilledPolygon(parameter color : Colors)
					Call to start drawing a polygon filled with a predefined color.
					WHITE, BLACK, RED, GREEN, BLUE, YELLOW, MAGENTA, CYAN, PINK, ORANGE, LIGHT_GRAY, DARK_GRAY
				
				operation startFilledPolygonRGB(parameter r : integer, parameter g : integer, parameter b : integer)
					Call to start drawing a polygon filled with a color defined by rgb values.
				
				operation endFilledPolygon()
					Call to finalize drawing a filled polygon.
				
				operation circle(parameter radius : integer)
					Call to draw a circle.
				
				operation filledCircle(parameter radius : integer, parameter color : Colors)
					Call to draw a filled circle with a predefined color.
					WHITE, BLACK, RED, GREEN, BLUE, YELLOW, MAGENTA, CYAN, PINK, ORANGE, LIGHT_GRAY, DARK_GRAY
				
				operation filledCircleRGB(parameter radius : integer, parameter r : integer, parameter g : integer, parameter b : integer)
					Call to draw a filled circle with a color defined by rgb values.
				
				operation setAnimationSpeed(parameter speed : Speed)
					Sets the speed of animation to a predefined value.
					SLOW, MEDIUM, FAST, INSTANT
				
				operation showCoordinateSystem(parameter bool : boolean)
					Pass true as a parameter to show the grid.
				
				operation activateDrawMode(parameter speed : Speed)
					Call it to play around with arrow keys.
				
				operation showCursor(parameter bool : boolean)
					Pass false to hide the cursor.
			''')
			addFile('''---HELP---/1.06 - UBTMicroworld.txt''', '''
				//------------------------------------------------------
				// This library allows to control one or several agents in maze-like environments.
				// It can be seen, as a small game, where users can learn to program while having a little fun.
				// Check the example in the example files.
				//------------------------------------------------------	
				library UBTMicroworld
				
				abstract type Agent : composition
					operation getXPosition() : integer
					operation getYPosition() : integer
					operation getXstartPosition() : integer	
					operation getYstartPosition() : integer
					operation moveForward()
					operation moveBackward()
					operation rotateRight()
					operation rotateLeft()
					operation doNothing()
					operation isTileInFrontOfWalkable() : boolean
					operation isTileBehindWalkable() : boolean
					operation getID() : integer	
					operation getStepsMade() : integer
					operation getNumberInputs() : integer	
					operation getNumberInvalidInputs() : integer
					operation getLastMoveDirection() : MoveDirection
					operation getMoveDirectionList() : list<MoveDirection>
					operation getLineOfSight() : LineOfSight	
					operation getNumberOfCollectedObjects() : integer
				endtype
				
				type DefaultLevelType : enumeration	
					DEFAULT_LEVEL_0, DEFAULT_LEVEL_1, DEFAULT_LEVEL_2, DEFAULT_LEVEL_3, DEFAULT_LEVEL_4, DEFAULT_LEVEL_5, DEFAULT_LEVEL_6, DEFAULT_LEVEL_7, DEFAULT_LEVEL_8, 
					DEFAULT_LEVEL_9, DEFAULT_LEVEL_10, DEFAULT_LEVEL_11, DEFAULT_LEVEL_12, DEFAULT_LEVEL_13, DEFAULT_LEVEL_14, DEFAULT_LEVEL_15, DEFAULT_LEVEL_16
				endtype
					
				type DelayTime : enumeration
					NO_DELAY, SHORT_DELAY, MEDIUM_DELAY, LONG_DELAY
				endtype
				
				type LineOfSight : enumeration
					NORTH, EAST, SOUTH, WEST
				endtype
					
				type MoveDirection : enumeration
					FORWARD, BACK, RIGHT, LEFT, NONE, INVALID, FORWARD_INVALID, BACK_INVALID
				endtype
					
				type ObjectType : enumeration		
					NO_OBJECT, KEY		
				endtype
				
				type TerrainType : enumeration	
					GRASS, SAND, PATH, SNOW, STONE, WATER, TARGET, START
				endtype
					
				type WinValidatorType : enumeration		
					VALIDATOR_1, VALIDATOR_2, VALIDATOR_3, CUSTOM		
				endtype
				
				
				operation initCustomGame1(parameter terrain : list<list<TerrainType>>, parameter validator : WinValidatorType) 
					Initializes a custom level with a terrain map defined as a 2D list of terrain types and a win validator.
				
				operation initCustomGame2(parameter terrain : list<list<TerrainType>>, parameter objects : list<list<ObjectType>>, parameter validator : WinValidatorType) 
					Same as	the above operation with the addition of the objects map defined by a 2D list of object types.
				
				operation initCustomGame3(parameter terrainMapPath : string, parameter validator : WinValidatorType) 
					Initializes a custom level with a terrain map defined by a path to an image and a win validator.
				
				operation initCustomGame4(parameter terrainMapPath : string, parameter objectsMapPath : string, parameter validator : WinValidatorType) 
					Same as the above operation with the addition of the objects map defined by a path to an image.
				
				operation initDefaultGame(parameter value : DefaultLevelType) 
					Initializes one of the predefined levels.
				
				operation getAgentList() : list<reference<Agent>> 
					Returns the list of agents.
				
				operation getNavMap() : list<list<String>> 
					Returns a 2D list of strings representing a simple navigational map, which shows accessible and inaccessible tiles as well as the start and target tiles.
				
				operation getTerrainType(parameter x : integer, parameter y : integer) : TerrainType 
					Returns	the TerrainType of the tile at the specified coordinates.
				
				operation isGameRunning() : boolean 
					Returns true if the game is not finished.
				
				operation setDelayTime(parameter delayTime : DelayTime) 
					Sets the delay time between actions performed by the agents.
				
				operation setGameFinished() 
					Sets the state of the game to game finished.
				
				operation setGameOver() 
					Sets the state of the game to game over.
				
				operation registerAgentForKeyListener(parameter agent : reference<Agent>) 
					Registers an agent for a key listener, this agent can now be controlled by the arrow keys on the keyboard. 
					Only one agent can be registered.
			''')
			addFile('''---HELP---/1.07 - GUIFactory.txt''', '''
				//------------------------------------------------------
				// This library is separated into several smaller library units.
				// It allows to implement simple graphical user interfaces.
				// It containes enumerations, abstract compositions, that must be used as reference types to declare variables,
				// and creation operations, which create actual instances that correspond to the abstract types.
				// Check the example in the example files.
				//------------------------------------------------------	
				
				//------------------------------------------------------
				library GUIFactory
				import GUIFactoryPanes
				
				type Palette : enumeration
						LIGHT_RED, RED, DARK_RED, CYAN,
						LIGHT_BLUE, BLUE, DARK_BLUE,
						LIGHT_YELLOW, YELLOW, DARK_YELLOW,
						LIGHT_GREEN, GREEN, DARK_GREEN, ORANGE,
						GOLD, LIGHT_GREY, GREY, DARK_GREY,
						LIGHT_BROWN, BROWN, DARK_BROWN, PURPLE,
						BLACK, WHITE, TRANSPARENT
				endtype
				
				type HorizontalAlignment : enumeration
					LEFT, CENTER, RIGHT
				endtype
				
				type FontType : enumeration
					PLAIN, ITALIC, BOLD, ITALIC_BOLD
				endtype
				
				type CheckBoxAlignment : enumeration
					NONE, ICON_LEFT_TEXT_RIGHT, ICON_RIGHT_TEXT_LEFT, ICON_TEXT_LEFT, ICON_TEXT_RIGHT
				endtype
				
				type Alignment : enumeration
					TOP_LEFT, TOP_CENTER, TOP_RIGHT, CENTER_LEFT, CENTER, CENTER_RIGHT, BOTTOM_LEFT, BOTTOM_CENTER, BOTTOM_RIGHT, NONE
				endtype
				
				
				abstract type Window : composition
					operation showWindow() 
					operation setPane(parameter pane : reference<GUIFactoryPanes.Pane>) 
					operation getPane() : reference<GUIFactoryPanes.Pane> 
					operation setSize(parameter width : integer, parameter height : integer) 
					operation setResizable(parameter resizable : boolean) 
					operation setTitle(parameter title : string) 
				endtype
				
				operation createWindow(parameter title : string, parameter width : integer, parameter height : integer) : reference<Window> 
				
				abstract type Colour : composition
				endtype
				
				operation createColour(parameter r : integer, parameter g : integer, parameter b : integer, parameter a : integer) : Colour
				operation createColourFromPalette(parameter palette : Palette) : Colour

				//------------------------------------------------------
				library GUIFactoryBorders
				import GUIFactory
				
				type BorderType : enumeration
					RAISED, LOWERED
				endtype
				
				
				abstract type Border : composition
				endtype
				
				abstract type TitledBorder : composition extends Border
				endtype
				operation createTitledBorder(parameter colour : GUIFactory.Colour, parameter thickness : integer, parameter title : string) : reference<TitleBorder>
				
				abstract type LineBorder : composition extends Border
				endtype
				operation createLineBorder(parameter colour : GUIFactory.Colour, parameter thickness : integer, parameter rounded : boolean) : reference<LineBorder>
				
				abstract type BevelBorder : composition extends Border
				endtype
				operation createBevelBorder(parameter borderType : BorderType, parameter highlight : GUIFactory.Colour, parameter shadow : GUIFactory.Colour) : reference<BevelBorder>
				
				//------------------------------------------------------
				library GUIFactoryComponents
				import GUIFactoryTasks
				import GUIFactory
				
				
				abstract type Component : composition
					operation setVisible(parameter visible : boolean) 
					operation getParent() : reference<Component> 
				endtype
				
				abstract type Image : composition extends Component
					operation setScale(parameter scale : rational)
					operation setSize(parameter width : integer, parameter height : integer)
					operation getWidth() : integer
					operation getHeight() : integer
					operation setTransparency(parameter alpha : rational)
					operation getTransparency() : rational
				endtype
				
				operation createImage(parameter path : string) : reference<Image>
				
				abstract type Label : composition extends Component
					operation setText(parameter text : string)
					operation getText() : string
					operation setTextAlignment(parameter alignment : GUIFactory.Alignment)
					operation setSize(parameter width : integer, parameter height : integer)
					operation setFont(parameter fontName : string, parameter fontType : FontType, parameter fontSize : integer, parameter colour : Colour)
					operation getWidth() : integer
					operation getHeight() : integer
				endtype
				
				abstract type TextField : composition extends Component
					operation setText(parameter text : string)
					operation getText() : string
					operation setEditable(parameter editable : boolean)
					operation isEditable() : boolean
					operation setBackground(parameter colour : GUIFactory.Colour)
					operation setSize(parameter width : integer, parameter height : integer)
					operation setFont(parameter fontName : string, parameter fontType : FontType, parameter fontSize : integer, parameter colour : Colour)
					operation getWidth() : integer
					operation getHeight() : integer
				endtype
				
				abstract type TextArea : composition extends Component
					operation setText(parameter text : string)
					operation getText() : string
					operation setEditable(parameter editable : boolean)
					operation isEditable() : boolean
					operation setBackground(parameter colour : GUIFactory.Colour)
					operation setSize(parameter width : integer, parameter height : integer)
					operation setFont(parameter fontName : string, parameter fontType : FontType, parameter fontSize : integer, parameter colour : Colour)
					operation getWidth() : integer
					operation getHeight() : integer
				endtype
				
				operation createLabel(parameter text : string) : reference<Label>
				operation createTextField(parameter alignment : GUIFactory.HorizontalAlignment, parameter text : string) : reference<TextField>
				operation createTextArea(parameter text : string) : reference<TextArea>
				
				abstract type Button : composition extends Component
					operation handleActionTask(parameter actionTask : reference<GUIFactoryTasks.ActionTask>)
					operation setText(parameter text : string)
					operation setActive(parameter active : boolean)
					operation isActive()
					operation getText() : string
					operation setSize(parameter width : integer, parameter height : integer)
					operation setFont(parameter fontName : string, parameter fontType : FontType, parameter fontSize : integer, parameter colour : Colour)
					operation getWidth() : integer
					operation getHeight() : integer
				endtype
				
				abstract type CheckBox : composition extends Component
					operation setSize(parameter width : integer, parameter height : integer)
					operation isSelected() : boolean
					operation getWidth() : integer
					operation getHeight() : integer
				abstract endtype
				
				abstract type DropDownMenu : composition extends Component
					operation setSize(parameter width : integer, parameter height : integer)
					operation getSelectedItem() : string
					operation getWidth() : integer
					operation getHeight() : integer
				endtype
				
				abstract type Slider : composition extends Component
					operation setSize(parameter width : integer, parameter height : integer)
					operation getValue() : integer
					operation getWidth() : integer
					operation getHeight() : integer
				endtype
				
				operation createButton(parameter text : string) : reference<Button>
				operation createCheckBox(parameter alignment : GUIFactory.CheckBoxAlignment, parameter text : string, parameter selected : boolean) : reference<CheckBox>
				operation createDropDownMenu(parameter itemNames : list<string>) : reference<DropDownMenu>
				operation createSlider(parameter minimum : integer, parameter maximum : integer, parameter value : integer) : reference<Slider>
				
				abstract type Shape : composition extends Component
					operation setSize(parameter width : integer, parameter height : integer)
					operation getWidth() : integer
					operation getHeight() : integer
					operation setImage(parameter image : reference<Image>)
					operation getImage() : reference<Image>
					operation setColour(parameter colour : GUIFactory.Colour)
					operation getColour() : GUIFactory.Colour	
				endtype
				
				abstract type Polygon : composition extends Shape
					operation addPoint(parameter x : integer, parameter y : integer)
				endtype
				
				abstract type Ellipse : composition extends Shape
				endtype
				
				abstract type Rectangle : composition extends Shape
				endtype
				
				operation createRectangle(parameter width : integer, parameter height : integer) : reference<Rectangle>
				operation createEllipse(parameter width : integer, parameter height : integer) : reference<Ellipse>
				operation createPolygon(parameter xPoint : list<integer>, parameter yPoints : list<integer>, parameter points : integer) : reference<Polygon>
				
				//------------------------------------------------------
				library GUIFactoryPanes
				import GUIFactory
				import GUIFactoryBorders
				
				operation createGridPane(parameter columnSpace : integer, parameter rowSpace : integer) : reference<GridPane>
				operation createHorizontalPane(parameter alignment : GUIFactory.Alignment, parameter spacing : integer) : reference<HorizontalPane>
				operation createVerticalPane(parameter alignment : GUIFactory.Alignment, parameter spacing : integer) : reference<VerticalPane>
				operation createBorderPane(parameter hgap : integer, parameter vgap : integer) : reference<BorderPane>
				
				abstract type Pane : composition extends Component
					operation setBorder(parameter border : reference<GUIFactoryBorders.Border>)
				endtype
				
				abstract type GridPane : composition extends Pane
					operation setPadding(parameter top : integer, parameter left : integer, parameter bottom : integer, parameter right : integer)
					operation setSpacing(parameter columnSpace : integer, parameter rowSpace : integer)
					operation addComponent(parameter component : reference<GUIFactory.Component>, parameter column : integer, parameter row : integer)
				endtype
				
				abstract type BorderPane : composition extends Pane
					operation setPadding(parameter top : integer, parameter left : integer, parameter bottom : integer, parameter right : integer)
					operation setTop(parameter component : reference<GUIFactory.Component>)
					operation setLeft(parameter component : reference<GUIFactory.Component>)
					operation setCenter(parameter component : reference<GUIFactory.Component>)
					operation setRight(parameter component : reference<GUIFactory.Component>)
					operation setBottom(parameter component : reference<GUIFactory.Component>)
				endtype
				
				abstract type VerticalPane : composition extends Pane
					operation setPadding(parameter top : integer, parameter left : integer, parameter bottom : integer, parameter right : integer)
					operation setSpacing(parameter spacing : integer)
					operation addComponent(parameter component : reference<GUIFactory.Component>)
				endtype
				
				abstract type HorizontalPane : composition extends Pane
					operation setPadding(parameter top : integer, parameter left : integer, parameter bottom : integer, parameter right : integer)
					operation setSpacing(parameter spacing : integer)
					operation addComponent(parameter component : reference<GUIFactory.Component>)
				endtype
				
				//------------------------------------------------------
				library GUIFactoryTasks
				
				abstract type ActionTask : composition
					abstract operation actionPerformed()
				endtype
			''')
			addFile('''---HELP---/2.00 - Examples.txt''', '''
				In the following files you will find some program examples.
				You can create a new mule file and copy and paste the content of these files to test it.
			''')
			addFile('''---HELP---/2.01 - if-statement.txt''', '''
				import IO  
				 
				main 
					variable a : boolean
					a := true
				
					if a /= false then 
						a := false
					endif
					
					variable b : integer
					b := 5
				
					if (not a and not ((2 + 3) = b) ) then   
					else
						if (a) then   
						endif
					endif
					
					if a then 
						IO.writeString("if")
					elseif not a then 
						IO.writeString("elseif")		
					else
						IO.writeString("else")
					endif
					
					if a then 	
						IO.writeString("if")
					elseif b /= 5 then
						IO.writeString("elseif1")			
					elseif b = 5 and not a then 
						IO.writeString("elseif2")			
					else 
						IO.writeString("else")
					endif
					
				endmain
			''')
			addFile('''---HELP---/2.02 - loop-statement.txt''', '''
				import IO 
				
				main
					variable i : integer
					i := 0
					loop // while ... do ...
						if (i < 5) then 
								IO.writeInteger(i)   
								i := i + 1
							else
								exit
						endif
					endloop
					IO.writeLine()
					
					i := 0
					loop // do ... while ...
						IO.writeInteger(i)
						i := i + 1
						if (i >= 5) then
							exit
						endif
					endloop
					IO.writeLine()
					
					loop
						loop
							IO.writeString("Please enter a number between 4 and 8: ")
							variable j : integer
							j := IO.readInteger()
							if (j >= 4 and j <= 8) then
								exit
							endif
						endloop
						IO.writeString("Again? (J/N)")
						if (IO.readString() = "Y") then
							exit
						endif
					endloop
				endmain
			''')
			addFile('''---HELP---/2.03 - let-statement.txt''', '''
				import IO
				
				type Transport : composition 
					operation print() 
						IO.writeString("Transport\n")
					endoperation
				endtype
				
				type Wheeled : composition extends Transport 
					override operation print() 
						IO.writeString("Wheeled\n")
					endoperation
					operation drive()
						IO.writeString("driving\n") 
					endoperation
				endtype
				
				type Airplane : composition extends Transport 
					override operation print() 
						IO.writeString("Airplane\n")
					endoperation
					operation fly()
						IO.writeString("flying\n")
					endoperation
				endtype
				
				type Car : composition extends Wheeled
					override operation print() 
						IO.writeString("Car\n")
					endoperation
					override operation drive()
						IO.writeString("car is ") 
						super.drive()
					endoperation
				endtype
				
				type Person : composition
				endtype
				
				type List<T extends Transport> : composition // <T extends SomeType>  
					attribute head : reference<T>
					attribute tail : reference<List<T>>
					
					operation append(parameter v : reference<T>) 
						if head = null then
							head := v
						elseif tail = null then
							tail := reference List{head = v, tail = null}
						else
							tail@.append(v) 
						endif 
					endoperation 
					
					operation get(parameter i : integer) : reference<T>
						return getHelper(i, 0)
					endoperation
					
					operation getHelper(parameter i : integer, parameter counter : integer) : reference<T>
						if i = counter then
							return head
						else 
							if tail = null then
								return null
							else
								return tail@.getHelper(i, counter + 1)
							endif
						endif
					endoperation
					
					operation print()
						head@.print()  
						if tail /= null then   
							tail@.print()  
						endif
					endoperation
				endtype
				
				main 
					variable lst : List<Transport>  
					variable f1 : reference<Wheeled>
					f1 := reference Wheeled{} 
					variable f2 : reference<Airplane>
					f2 := reference Airplane{}
					variable f3 : reference<Car>
					f3 := reference Car{}
					lst.append(f1)
					lst.append(f2) 
					lst.append(f3)
					lst.print()
					IO.writeLine()   
					 
					variable i : integer 
					loop 
						if lst.get(i) = null then  
							exit 
						endif 
						// test with non parameterized types
						let variable ff : Airplane be lst.get(i)@ do 
							ff.fly()
						elselet variable ff : Wheeled be lst.get(i)@ do  
							ff.drive()
						elselet variable ff : Car be lst.get(i)@ do 
							ff.drive()   
						endlet 
						// test with parameterized types
						let variable ff : reference<Airplane> be lst.get(i) do
							ff@.fly()
						elselet variable ff : reference<Wheeled> be lst.get(i) do  
							ff@.drive()
						elselet variable ff : reference<Car> be lst.get(i) do 
							ff@.drive()   
						endlet
						i := i + 1
					endloop
				endmain
			''')
			addFile('''---HELP---/2.04 - Operations.txt''', '''
				import IO
				import Strings
				
				operation functionExample(parameter a : integer, parameter b : integer) : integer 
					return a + b
				endoperation
				 
				
				operation procedureExample(parameter a : integer, parameter b : integer) 
					variable c : integer 
					c := a
					a := b
					b := c 
					IO.writeString(Strings.integerToString(a) & " " & Strings.integerToString(b) & "\n") // prints 3 2
				endoperation
				
				main       
					IO.writeInteger(functionExample(2, 3)) IO.writeLine()
					variable x : integer variable y : integer
					x := 2
					y := 3
					procedureExample(x, y)
					IO.writeString(Strings.integerToString(x) & " " & Strings.integerToString(y) & "\n") // prints 2 3, because local values of x and y are not changed
				endmain
			''')
			addFile('''---HELP---/2.05 - Compositions.txt''', '''
				import IO 
				import Strings 
				
				type Book : composition 
					attribute author : string
					attribute title : string
					attribute isbn : string
				endtype
				
				type Point : composition 
					attribute a : integer
					attribute b : integer 
				endtype
				
				main 
					variable book1 : Book 
					variable bookAuthor : string 
					bookAuthor := book1.author  
					book1.author := book1.author
					book1.isbn := "978-1-78216-030-4"
					book1.author := "Lorenzo Bettini"
					book1.title := "Implementing Domain-Specific-Languages with Xtext and Xtend"
					IO.writeString(Strings.genericToString(book1) & "\n" & bookAuthor)
				endmain   
			''')
			addFile('''---HELP---/2.06 - Enumerations.txt''', '''
				import IO 
				import Strings 
				
				type ColorRGB : enumeration 
					RED, GREEN, BLUE
				endtype
				
				type ColorCMY : enumeration 
					CYAN, MAGENTA, YELLOW
				endtype
				
				main 
					variable r : ColorRGB
					r := ColorRGB.RED
					variable c : ColorCMY
					c := ColorCMY.CYAN
					IO.writeString(Strings.genericToString(r) & "\n" & Strings.genericToString(c))
				endmain
			''')
			addFile('''---HELP---/2.07 - Reference Types.txt''', '''
				import IO 
				import Strings 
				
				type Point : composition        
					attribute x : integer
					attribute y : integer
				endtype
				
				main        
					variable object : Point   
					variable copy : Point 
					variable ref : reference<Point> 	
					
					IO.writeString("Object:   " & Strings.genericToString(object) & "\n")  
					IO.writeString("Copy:    " & Strings.genericToString(copy) & "\n")  
					IO.writeString("Reference: " & Strings.genericToString(ref) & "\n" & "\n")  
					
					object.x := 2 
					object.y := 3
					
					copy := object 
					object.x := 5   
											
					IO.writeString("Object:   " & Strings.genericToString(object) & "\n")  
					IO.writeString("Copy:    " & Strings.genericToString(copy) & "\n")  
					IO.writeString("Reference: " & Strings.genericToString(ref) & "\n" & "\n")  
					
					ref := reference object       
					object.x := 7 
					
					IO.writeString("Objekt:   " & Strings.genericToString(object) & "\n")  
					IO.writeString("Kopie:    " & Strings.genericToString(copy) & "\n")  
					IO.writeString("Referenz: " & Strings.genericToString(ref) & "\n" & "\n")  
					
					ref@.y := 1 		 
					
					IO.writeString("Object:   " & Strings.genericToString(object) & "\n")  
					IO.writeString("Copy:    " & Strings.genericToString(copy) & "\n")  
					IO.writeString("Reference: " & Strings.genericToString(ref) & "\n" & "\n")  
				endmain
			''')
			addFile('''---HELP---/2.08 - Lists.txt''', '''
				import IO
				import Strings
				
				main
					variable empty : list<string>
					empty := []
					variable elements : list<string>
					elements := ["a"]
					elements := ["a", "b", "c"]
					elements[1] := "x"
					
					variable repetition : list<rational>
					repetition := [3 ** 3.14] // [3.14, 3.14, 3.14]    
					IO.writeString(Strings.genericToString(empty))
					IO.writeString(Strings.genericToString(elements))
					IO.writeString(Strings.genericToString(repetition))
					
					variable list1 : list<integer>
					list1 := [0 .. 2]
					variable list2 : list<integer>
					list2 := [3, 4, 5]
					
					variable lists : list<list<integer>>
					lists := [list1, list2]
					
					variable nested2D : list<list<integer>>
					nested2D := [[0, 1, 2], [6 ** 3], [4 .. 6]]
					variable nested3D : list<list<list<integer>>>
					nested3D := [[[0, 0], [1, 1]], [[2, 2], [3, 3]]]
					variable nested3D2 : list<list<list<integer>>>
					nested3D2 := [[[0, 0], [1, 1]], [[2, 2], [3, 3]]]
					IO.writeLine()
					
					variable chessboard : list<list<string>>
					chessboard := [8 ** [8 ** "Field"]]
					variable i : integer
					loop
						if i = 8 then
							exit
						endif
						IO.writeString(Strings.genericToString(chessboard[i]) & "\n")
						i := i + 1
					endloop
					IO.writeString(chessboard[1][1])
				endmain
			''')
			addFile('''---HELP---/2.09 - List Operations.txt''', '''					
				import Lists  
				import IO 
				import Strings 
				
				main  
					variable _list : list<string> 
					_list := ["a", "b", "c"]    
					_list[1] := "x"
					
					variable empty : boolean 	empty := Lists.isEmpty(_list)  
					variable length : integer 	length := Lists.lengthOf(_list)  
					variable index : integer	index := Lists.indexOf(_list, "x")   
				
					_list := Lists.append(_list, "d") 
					_list := Lists.append(_list, ["e", "f"]) 
					_list := Lists.append(_list, _list)   
					
					variable _head : string 	_head := Lists.head(_list)	
					variable _tail : list<string> 	_tail := Lists.tail(_list)
					variable _subList : list<string> 	_subList := Lists.subList(_list, 0, 3)  	
					variable _last : string 	_last := Lists.last(_list)       
					
					_list := Lists.insert(_list, "0", 0)  
					_list := Lists.insert(_list, ["1", "2", "3"], 1)
					IO.writeString(Strings.genericToString(_list) & "\n")
					
					_list := Lists.removeElement(_list, "2")  
					_list := Lists.removePosition(_list, 3) 
					IO.writeString(Strings.genericToString(_list) & "\n") 
					Lists.removeElement(_list, "x") // Nothing happens in the _list variable, since there is no assignment
					IO.writeString(Strings.genericToString(_list))
				endmain
			''')
			addFile('''---HELP---/2.10 - Turtle.txt''', '''					
				import IO
				import Turtle
				import Mathematics
				
				main
					Turtle.setAnimationSpeed(Turtle.Speed.FAST)
					Turtle.setThickness(3)
					Turtle.setDirection(90)
					Turtle.setPosition(250, 300)
					variable edges : integer
					edges := 3
					loop
						if edges > 8 then
							exit
						endif
						Turtle.setColorRGB(Mathematics.randomInteger(0, 255), Mathematics.randomInteger(0, 255), Mathematics.randomInteger(0, 255))
						variable edge : integer
						edge := 1
						loop
							if edge > edges then
								exit
							endif
							Turtle.forward(100)
							Turtle.left(360 / edges)
							edge := edge + 1
						endloop
						edges := edges + 1
					endloop
				endmain
			''')
			addFile('''---HELP---/2.11 - UBTMicroworld.txt''', '''					
				program CustomLevelWithKeyListener
				import UBTMicroworld  
				import Mathematics
				
				main	
					variable g : UBTMicroworld.TerrainType g := UBTMicroworld.TerrainType.GRASS
					variable s : UBTMicroworld.TerrainType s := UBTMicroworld.TerrainType.STONE
					variable O : UBTMicroworld.TerrainType O := UBTMicroworld.TerrainType.START
					variable T : UBTMicroworld.TerrainType T := UBTMicroworld.TerrainType.TARGET
					variable X : UBTMicroworld.ObjectType  X := UBTMicroworld.ObjectType.KEY
					variable _ : UBTMicroworld.ObjectType  _ := UBTMicroworld.ObjectType.NO_OBJECT
					UBTMicroworld.initCustomGame2( 
						[[O, g, g, g, g],
					 	 [g, s, g, s, g],
						 [g, g, g, g, T],
						 [g, s, g, s, g],
						 [O, g, g, g, g]], 
						[[_, _, X, _, X],
						 [_, _, _, _, _],
						 [X, _, X, _, _],
						 [_, _, _, _, _],
						 [_, _, X, _, X]], 
						UBTMicroworld.WinValidatorType.CUSTOM)
					UBTMicroworld.setDelayTime(UBTMicroworld.DelayTime.NO_DELAY)
					variable player : reference<UBTMicroworld.Agent>
					player := UBTMicroworld.getAgentList()[0] 
					variable enemy : reference<UBTMicroworld.Agent>
					enemy := UBTMicroworld.getAgentList()[1] 
					UBTMicroworld.registerAgentForKeyListener(player)	
					variable playersMoves : integer
					variable playersTurn : boolean
					loop
						if UBTMicroworld.isGameRunning() then 			
							if not playersTurn then
								if Mathematics.randomInteger(1, 2) = 1 then
									enemy@.rotateLeft()
								else
									enemy@.rotateRight()
								endif
								enemy@.moveForward() 
								playersTurn := true
							else 
								if player@.getNumberInputs() > playersMoves then
									playersMoves := playersMoves + 1
									playersTurn := false
								endif
							endif
							if enemy@.getXPosition() = player@.getXPosition() and enemy@.getYPosition() = player@.getYPosition() then
								UBTMicroworld.setGameOver()
							elseif player@.getNumberOfCollectedObjects() >= 3 and player@.getXPosition() = 4 and player@.getYPosition() = 2 then
								UBTMicroworld.setGameFinished()
							endif
						else
							exit
						endif 
					endloop
				endmain
			''')			
			addFile('''---HELP---/2.12 - GUIFactory.txt''', '''					
				program simpleIO
				import GUIFactory
				import GUIFactoryBorders
				import GUIFactoryPanes
				import GUIFactoryComponents
				import GUIFactoryTasks
				
				type Button1ActionTask : composition extends GUIFactoryTasks.ActionTask
					private attribute _textField : reference<GUIFactoryComponents.TextField>
					private attribute _textArea : reference<GUIFactoryComponents.TextArea>
					
					override operation actionPerformed() 
						variable text : string
						text := _textArea@.getText() & "\n   " & _textField@.getText()
						_textArea@.setText(text)
					endoperation
				endtype
				
				type Button2ActionTask : composition extends GUIFactoryTasks.ActionTask
					private attribute _textField : reference<GUIFactoryComponents.TextField>
					private attribute _textArea : reference<GUIFactoryComponents.TextArea>
					
					override operation actionPerformed() 
						_textField@.setText(" Enter name here")
						_textArea@.setText(" Registered names are:")
					endoperation
				endtype
				
				main
					variable window : reference<GUIFactory.Window> 
					window := GUIFactory.createWindow("Simple IO", 450, 300)
					window@.setResizable(false)
					
					variable mainPane : reference<GUIFactoryPanes.VerticalPane>
					mainPane := GUIFactoryPanes.createVerticalPane(GUIFactory.Alignment.TOP_CENTER, 10)	
					mainPane@.setPadding(10, 10, 10, 10)
					window@.setPane(mainPane)
					
					variable outerBorder : reference<GUIFactoryBorders.TitledBorder>
					outerBorder := GUIFactoryBorders.createTitledBorder(GUIFactory.createColour(55, 55, 55, 255), 1, "outer pane")
					mainPane@.setBorder(outerBorder)
					
					variable textArea : reference<GUIFactoryComponents.TextArea>
					textArea := GUIFactoryComponents.createTextArea(" Registered names are:")
					textArea@.setEditable(false)
						
					/////////////////////////////////////////////////////////////////
					variable secondaryPane : reference<GUIFactoryPanes.HorizontalPane>
					secondaryPane := GUIFactoryPanes.createHorizontalPane(GUIFactory.Alignment.CENTER, 10)
					secondaryPane@.setPadding(10, 10, 10, 10)
					
					variable textField : reference<GUIFactoryComponents.TextField>
					textField := GUIFactoryComponents.createTextField(GUIFactory.HorizontalAlignment.LEFT, " Enter name here")
					textField@.setSize(200, 28)  
				
					variable button1 : reference<GUIFactoryComponents.Button>
					button1 := GUIFactoryComponents.createButton("Save")	
					button1@.handleActionTask(reference Button1ActionTask{_textField = textField, _textArea = textArea})
				
					variable button2 : reference<GUIFactoryComponents.Button>
					button2 :=  GUIFactoryComponents.createButton("Reset")	
					button2@.handleActionTask(reference Button2ActionTask{_textField = textField, _textArea = textArea})
					
					
					variable innerBorder : reference<GUIFactoryBorders.TitledBorder>
					innerBorder := GUIFactoryBorders.createTitledBorder(GUIFactory.createColourFromPalette(GUIFactory.Palette.LIGHT_GREY), 1, "inner pane")
					
					secondaryPane@.addComponent(textField) 
					secondaryPane@.addComponent(button1) 
					secondaryPane@.addComponent(button2) 
					secondaryPane@.setBorder(innerBorder)
					
				
					/////////////////////////////////////////////////////////////////
					
					mainPane@.addComponent(secondaryPane) 
					mainPane@.addComponent(textArea)  
					
					window@.showWindow() 
				endmain				
			''')
		])
//		else
//			new Status(ERROR, "Wizard", "'" + projectInfo.projectName + "' is not a valid project name")
	}

//@ProjectTemplate(label="Hello World", icon="project_template.png", description="<p><b>Hello World</b></p>
//<p>This is a parameterized hello world for MuLE. You can set a parameter to modify the content in the generated file
//and a parameter to set the package the file is created in.</p>")
//final class HelloWorldProject {
//	val advanced = check("Advanced:", false)
//	val advancedGroup = group("Properties")
//	val name = combo("Name:", #["Xtext", "World", "Foo", "Bar"], "The name to say 'Hello' to", advancedGroup)
//	val path = text("Package:", "mydsl", "The package path to place the files in", advancedGroup)
//
//	override protected updateVariables() {
//		name.enabled = advanced.value
//		path.enabled = advanced.value
//		if (!advanced.value) {
//			name.value = "Xtext"
//			path.value = "mule"
//		}
//	}
//
//	override protected validate() {
//		if (path.value.matches('[a-z][a-z0-9_]*(/[a-z][a-z0-9_]*)*'))
//			null
//		else
//			new Status(ERROR, "Wizard", "'" + path + "' is not a valid package name")
//	}
//
//	override generateProjects(IProjectGenerator generator) {
//		generator.generate(new PluginProjectFactory => [
//			projectName = projectInfo.projectName
//			location = projectInfo.locationPath
//			projectNatures += #[JavaCore.NATURE_ID, "org.eclipse.pde.PluginNature", XtextProjectHelper.NATURE_ID]
//			builderIds += #[JavaCore.BUILDER_ID, XtextProjectHelper.BUILDER_ID]
//			folders += "src"
//			addFile('''src/path/Model.mule''', '''
//				/*
//				 * This is an example model
//				 */
//				Hello name!
//			''')
//		])
//	}
}

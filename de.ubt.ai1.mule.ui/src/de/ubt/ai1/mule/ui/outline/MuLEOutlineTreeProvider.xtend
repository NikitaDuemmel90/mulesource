/*
 * generated by Xtext 2.16.0
 */
package de.ubt.ai1.mule.ui.outline

import com.google.inject.Inject
import de.ubt.ai1.mule.muLE.Attribute
import de.ubt.ai1.mule.muLE.CompilationUnit
import de.ubt.ai1.mule.muLE.Composition
import de.ubt.ai1.mule.muLE.Enumeration
import de.ubt.ai1.mule.muLE.EnumerationValue
import de.ubt.ai1.mule.muLE.Expression
import de.ubt.ai1.mule.muLE.Feature
import de.ubt.ai1.mule.muLE.Import
import de.ubt.ai1.mule.muLE.MainProcedure
import de.ubt.ai1.mule.muLE.Operation
import de.ubt.ai1.mule.muLE.Parameter
import de.ubt.ai1.mule.muLE.Statement
import de.ubt.ai1.mule.muLE.TypeDeclaration
import de.ubt.ai1.mule.muLE.TypeParameter
import de.ubt.ai1.mule.muLE.VariableDeclaration
import de.ubt.ai1.mule.typing.MuLETypeProvider
import org.eclipse.jface.viewers.StyledString
import org.eclipse.swt.graphics.RGB
import org.eclipse.xtext.ui.editor.outline.impl.DefaultOutlineTreeProvider
import org.eclipse.xtext.ui.editor.outline.impl.DocumentRootNode
import org.eclipse.xtext.ui.editor.utils.TextStyle
import org.eclipse.xtext.ui.label.StylerFactory

/**
 * Customization of the default outline structure.
 * 
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#outline
 */
class MuLEOutlineTreeProvider extends DefaultOutlineTreeProvider {

	@Inject extension MuLETypeProvider

	@Inject StylerFactory stylerFactory

	/**
	 * Following language elements are leafs, i.e. their attributes (e.g. data type of an operation or an attribute) are hidden.
	 * That means that no further details can be displayed about these elements.
	 * The required details are then represented as strings (see _text operations below)
	 */
	def _isLeaf(CompilationUnit a) { true } // <-- for the sake of convenience

	def _isLeaf(Feature a) { true }

	def _isLeaf(Expression a) { true }

	def _isLeaf(Statement a) { true }

	def _isLeaf(MainProcedure a) { true }

	def _isLeaf(TypeParameter a) { true }

	/**
	 * Imported Libraries can be accesses vua outline tree
	 * Adds Nodes for Type Declarations, Operations and the Main Block
	 */
	def void _createChildren(DocumentRootNode outlineNode, CompilationUnit program) {
		createNode(outlineNode, program)
		for (importStatement : program.imports) {
			createNode(outlineNode, importStatement)
			var node = outlineNode.children.last
			var importedLibrary = importStatement.importedNamespace
			if (importedLibrary !== null) {
				for (importStatement2 : importedLibrary.imports) {
					createNode(node, importStatement2)
				}
				for (programElement : importedLibrary.programElements) {
					var visibility = null as String
					if (programElement instanceof Composition)
						visibility = programElement.visibility
					if (programElement instanceof Enumeration)
						visibility = programElement.visibility
					if (programElement instanceof Operation)
						visibility = programElement.visibility
					if (visibility === null)
						createNode(node, programElement)
				}
			}
		}
		for (programElement : program.programElements) {
			createNode(outlineNode, programElement)
		}
		if (program.main !== null)
			createNode(outlineNode, program.main)
	}

	/**
	 * Returns StyledStrings for OutlineNodes
	 */
	def Object _text(CompilationUnit program) {
		var result = new StyledString()
		if (program.isLibrary)
			result.append("library ", stylerFactory.createXtextStyleAdapterStyler(getNodeTypeTextStyle()))
		else
			result.append("program ", stylerFactory.createXtextStyleAdapterStyler(getNodeTypeTextStyle()))
		if (program.name !== null)
			result.append(program.name)
		return result
	}

	def Object _text(Import imp) {
		var result = new StyledString()
		result.append("import ", stylerFactory.createXtextStyleAdapterStyler(getNodeTypeTextStyle()))
		if (imp.importedNamespace !== null && imp.importedNamespace.name !== null)
			result.append(imp.importedNamespace.name)
		return result
	}

	def Object _text(EnumerationValue v) {
		var result = new StyledString()
		// result.append("value ", stylerFactory.createXtextStyleAdapterStyler(getNodeTypeTextStyle()))
		if (v.name !== null)
			result.append(v.name)
		return result
	}

	def Object _text(VariableDeclaration attr) {
		var result = new StyledString()
		result.append("variable ", stylerFactory.createXtextStyleAdapterStyler(getNodeTypeTextStyle()))
		result.append(attr.name)
		var type = " : " + attr.type.typeFor(null).dataTypeToString
		result.append(type, stylerFactory.createXtextStyleAdapterStyler(getDataTypeTextStyle()))
		return result
	}

	def Object _text(TypeDeclaration type) {
		var result = new StyledString()
		switch type {
			Composition: {
				if (type.abstract)
					result.append("abstract ", stylerFactory.createXtextStyleAdapterStyler(getNodeTypeTextStyle()))
				result.append("composition ", stylerFactory.createXtextStyleAdapterStyler(getNodeTypeTextStyle()))
				result.append(type.name, stylerFactory.createXtextStyleAdapterStyler(getDataTypeTextStyle()))
				if (type.superType !== null && type.superType.name !== null) {
					result.append(" extends ", stylerFactory.createXtextStyleAdapterStyler(getNodeTypeTextStyle()))
					result.append(type.superType.name,
						stylerFactory.createXtextStyleAdapterStyler(getDataTypeTextStyle()))
				}
				if (!type.typeParams.empty) {
					var typeParamsString = "<"
					for (typeParam : type.typeParams) {
						typeParamsString += typeParam.name
						if (typeParam.superType !== null) {
							typeParamsString += " extends " + typeParam.superType.name
						}
						if (!type.typeParams.last.equals(typeParam)) {
							typeParamsString += ", "
						}
					}
					typeParamsString += ">"
					result.append(typeParamsString, stylerFactory.createXtextStyleAdapterStyler(getDataTypeTextStyle()))
				}
			}
			Enumeration: {
				result.append("enumeration ", stylerFactory.createXtextStyleAdapterStyler(getNodeTypeTextStyle()))
				result.append(type.name, stylerFactory.createXtextStyleAdapterStyler(getDataTypeTextStyle()))
			}
		}
		return result
	}

	def Object _text(TypeParameter p) {
		return null
	}

	def Object _text(Parameter p) {
		return null
	}

	def Object _text(Operation op) {
		var result = new StyledString()
		if (op.visibility !== null)
			result.append(op.visibility + " ", stylerFactory.createXtextStyleAdapterStyler(getNodeTypeTextStyle()))
		if (op.abstract)
			result.append("abstract ", stylerFactory.createXtextStyleAdapterStyler(getNodeTypeTextStyle()))
		result.append("operation", stylerFactory.createXtextStyleAdapterStyler(getNodeTypeTextStyle()))
		result.append(" " + op.name)
		result.append("(")
		for (param : op.params) {
			result.append("parameter", stylerFactory.createXtextStyleAdapterStyler(getNodeTypeTextStyle()))
			result.append(" " + param.name + " : ")
			if (param.type !== null) {
				var type = param.type.dataTypeToString
				if (type !== null)
					result.append(type, stylerFactory.createXtextStyleAdapterStyler(getDataTypeTextStyle()))
			}
			if (!op.params.last.equals(param)) {
				result.append(", ")
			}
		}
		result.append(")")
		if (op.type !== null) {
			result.append(" : ")
			var type = op.typeFor(null).dataTypeToString
			if (type !== null)
				result.append(type, stylerFactory.createXtextStyleAdapterStyler(getDataTypeTextStyle()))
		}
		return result
	}

	def Object _text(Attribute attr) {
		var result = new StyledString()
		if (attr.visibility !== null)
			result.append(attr.visibility + " ", stylerFactory.createXtextStyleAdapterStyler(getNodeTypeTextStyle()))
		result.append("attribute", stylerFactory.createXtextStyleAdapterStyler(getNodeTypeTextStyle()))
		var type = attr.typeFor(null).dataTypeToString
		result.append(" " + attr.name + " : ")
		if (type !== null)
			result.append(type, stylerFactory.createXtextStyleAdapterStyler(getDataTypeTextStyle()))
		return result
	}

	def Object _text(MainProcedure main) {
		return "main"
	}

	/**
	 * Grey color for Nodes
	 */
	def private getNodeTypeTextStyle() {
		var textStyle = new TextStyle();
		textStyle.setColor(new RGB(149, 149, 149));
		return textStyle;
	}

	/**
	 * Orange for data types
	 */
	def private getDataTypeTextStyle() {
		var textStyle = new TextStyle();
		textStyle.setColor(new RGB(204, 102, 0));
//		textStyle.setStyle(SWT.BOLD);
		return textStyle;
	}

}
